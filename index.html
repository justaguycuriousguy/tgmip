<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vaporwave Meme Maker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --neon-pink: #ff71ce;
            --neon-blue: #01cdfe;
            --neon-purple: #b967ff;
            --neon-green: #05ffa1;
            --dark-bg: #1a1a2e;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: "Segoe UI", sans-serif; margin: 0; padding: 16px; background-color: var(--dark-bg); color: white; }
        .canvas-container { position: relative; width: 100%; max-width: 600px; margin: auto; }
        #memeCanvas { width: 100%; border: 2px solid var(--neon-blue); border-radius: 12px; }
        .control-panel { display: flex; flex-direction: column; align-items: center; margin-top: 16px; }
        .button { background: var(--neon-purple); color: white; padding: 8px 12px; border: none; border-radius: 8px; cursor: pointer; margin: 5px 0; }
        .slider-container { width: 80%; margin: 8px 0; }
        .slider-container label { color: var(--neon-pink); display: block; font-size: 14px; margin-bottom: 4px; }
        input[type="range"] { width: 100%; }
    </style>
</head>
<body>
    <div class="canvas-container">
        <canvas id="memeCanvas" width="800" height="600"></canvas>
    </div>
    
    <div class="control-panel">
        <input type="file" id="fileInput" accept="image/*" style="display: none;">
        <button class="button" onclick="document.getElementById('fileInput').click()">Choose Background Image</button>
        <button class="button" onclick="addOverlay()">Add Overlay</button>
        <button class="button" onclick="saveMeme()">Save Image</button>
        
        <div class="slider-container">
            <label for="rotationSlider">Rotation</label>
            <input type="range" id="rotationSlider" min="0" max="360" value="0">
        </div>

        <div class="slider-container">
            <label for="scaleSlider">Size</label>
            <input type="range" id="scaleSlider" min="50" max="200" value="100">
        </div>
    </div>

<script>
    const canvas = document.getElementById('memeCanvas');
    const ctx = canvas.getContext('2d');
    const rotationSlider = document.getElementById('rotationSlider');
    const scaleSlider = document.getElementById('scaleSlider');

    let baseImage = new Image();
    let overlays = [];
    let activeOverlay = null;
    let isDragging = false;
    let startX, startY;

    // Load the background image
    document.getElementById('fileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                baseImage.src = event.target.result;
                baseImage.onload = () => {
                    drawCanvas();
                };
            };
            reader.readAsDataURL(file);
        }
    });

    // Function to draw the entire canvas
    function drawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (baseImage.src) {
            ctx.drawImage(baseImage, 0, 0, canvas.width, canvas.height);
        }
        overlays.forEach(overlay => {
            ctx.save();
            ctx.translate(overlay.x, overlay.y);
            ctx.rotate((overlay.rotation * Math.PI) / 180);
            ctx.scale(overlay.scale, overlay.scale);
            ctx.drawImage(overlay.image, -overlay.image.width / 2, -overlay.image.height / 2);
            ctx.restore();
        });
    }

    // Add a new overlay
    function addOverlay() {
        const overlayImage = new Image();
        overlayImage.src = 'https://via.placeholder.com/150'; // Placeholder; replace with desired image source
        overlayImage.onload = () => {
            const overlay = {
                image: overlayImage,
                x: canvas.width / 2,
                y: canvas.height / 2,
                rotation: 0,
                scale: 1,
            };
            overlays.push(overlay);
            activeOverlay = overlay;
            drawCanvas();
            updateSliders();
        };
    }

    // Save meme as an image
    function saveMeme() {
        const link = document.createElement('a');
        link.download = 'meme.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    }

    // Start dragging an overlay
    canvas.addEventListener('mousedown', (e) => {
        const [mouseX, mouseY] = getMousePos(e);
        activeOverlay = overlays.find(overlay => isOverlayClicked(overlay, mouseX, mouseY));
        if (activeOverlay) {
            isDragging = true;
            startX = mouseX - activeOverlay.x;
            startY = mouseY - activeOverlay.y;
            updateSliders();
        }
    });

    // Dragging event
    canvas.addEventListener('mousemove', (e) => {
        if (isDragging && activeOverlay) {
            const [mouseX, mouseY] = getMousePos(e);
            activeOverlay.x = mouseX - startX;
            activeOverlay.y = mouseY - startY;
            drawCanvas();
        }
    });

    // End dragging
    canvas.addEventListener('mouseup', () => {
        isDragging = false;
    });

    // Utility to get mouse position
    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        return [e.clientX - rect.left, e.clientY - rect.top];
    }

    // Check if the overlay is clicked
    function isOverlayClicked(overlay, x, y) {
        const dx = x - overlay.x;
        const dy = y - overlay.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        return dist < (overlay.image.width / 2) * overlay.scale;
    }

    // Update sliders to match the active overlay's properties
    function updateSliders() {
        if (activeOverlay) {
            rotationSlider.value = activeOverlay.rotation;
            scaleSlider.value = activeOverlay.scale * 100;
        }
    }

    // Handle rotation slider
    rotationSlider.addEventListener('input', () => {
        if (activeOverlay) {
            activeOverlay.rotation = parseInt(rotationSlider.value, 10);
            drawCanvas();
        }
    });

    // Handle scale slider
    scaleSlider.addEventListener('input', () => {
        if (activeOverlay) {
            activeOverlay.scale = parseFloat(scaleSlider.value) / 100;
            drawCanvas();
        }
    });

    // Keyboard transformations for fine control
    document.addEventListener('keydown', (e) => {
        if (!activeOverlay) return;
        if (e.key === 'ArrowUp') activeOverlay.scale += 0.05;
        if (e.key === 'ArrowDown') activeOverlay.scale = Math.max(0.1, activeOverlay.scale - 0.05);
        if (e.key === 'ArrowLeft') activeOverlay.rotation -= 5;
        if (e.key === 'ArrowRight') activeOverlay.rotation += 5;
        updateSliders();
        drawCanvas();
    });
</script>
</body>
</html>




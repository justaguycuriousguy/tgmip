<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Enhanced Meme Maker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- Security headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://cdnjs.cloudflare.com data: blob:; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; img-src 'self' data: blob: https://*;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,">
    
    <!-- Prevent Web3 provider injection -->
    <script>
        window.addEventListener('DOMContentLoaded', () => {
            // Freeze ethereum property if it exists
            if (!Object.getOwnPropertyDescriptor(window, 'ethereum')) {
                Object.defineProperty(window, 'ethereum', {
                    value: null,
                    writable: false,
                    configurable: false
                });
            }
            
            // Handle injection errors gracefully
            window.addEventListener('error', (event) => {
                if (event.message.includes('ethereum')) {
                    event.preventDefault();
                    console.warn('Ethereum provider injection blocked for security');
                }
            });
        });
    </script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --neon-pink: #ff71ce;
            --neon-blue: #01cdfe;
            --neon-purple: #b967ff;
            --neon-green: #05ffa1;
            --dark-bg: #1a1a2e;
            --grid-color: rgba(255, 113, 206, 0.1);
            --modal-bg: rgba(26, 26, 46, 0.95);
            --error-red: #ff4444;
            --success-green: #00C851;
            --warning-yellow: #ffbb33;
            --retrowave-gradient: linear-gradient(
                45deg,
                var(--neon-pink),
                var(--neon-purple),
                var(--neon-blue)
            );
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: manipulation;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto;
            margin: 0;
            padding: 16px;
            background-color: var(--dark-bg);
            color: white;
            min-height: 100vh;
            overscroll-behavior: none;
        }

        .app-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 0;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            padding-top: 75%;
            margin-bottom: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 15px var(--neon-blue);
            overflow: hidden;
        }

        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            background: #000;
        }

        #memeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            display: block;
        }

        .stogie-selector {
            width: 100%;
            margin: 8px 0;
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--neon-pink);
            border-radius: 12px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 0 10px var(--neon-pink);
            backdrop-filter: blur(5px);
            scrollbar-width: none;
        }

        .stogie-selector::-webkit-scrollbar {
            display: none;
        }

        .stogie-option {
            flex: 0 0 80px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--neon-purple);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 5px;
        }

        .stogie-option:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        .stogie-option img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 12px;
            margin: 8px 0;
            border: 1px solid var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
            backdrop-filter: blur(5px);
        }

        .button {
            background: var(--retrowave-gradient);
            color: white;
            border: none;
            padding: 16px 20px;
            border-radius: 8px;
            font-size: 16px;
            width: 100%;
            margin-bottom: 12px;
            cursor: pointer;
            transition: transform 0.2s ease;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .button:active {
            transform: scale(0.98);
        }

        .delete-button {
            background: linear-gradient(45deg, #ff0844, #ffb199);
        }

        .delete-button.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .slider-container {
            margin: 16px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 8px;
            color: var(--neon-pink);
            text-transform: uppercase;
            font-size: 14px;
            letter-spacing: 1px;
        }

        input[type="range"] {
            width: 100%;
            height: 36px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            outline: none;
            border: 1px solid var(--neon-blue);
            margin: 0;
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: var(--neon-purple);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--neon-purple);
            border: none;
            margin-top: -8px;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            border: none;
        }

        #fileInput {
            display: none;
        }

        .preview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--modal-bg);
            z-index: 1000;
            padding: 20px;
            backdrop-filter: blur(10px);
            touch-action: none;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .preview-content {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 20px var(--neon-blue);
            position: relative;
        }

        .preview-content h2 {
            margin: 0 0 20px 0;
            text-align: center;
            color: var(--neon-pink);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 20px;
        }

        .preview-image-container {
            width: 100%;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
        }

        .preview-image {
            width: 100%;
            display: block;
            border-radius: 8px;
        }

        .share-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .share-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--neon-purple);
            color: white;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .share-button.download {
            border-color: var(--neon-green);
        }

        .share-button.telegram {
            background: rgba(0, 136, 204, 0.2);
            border-color: #0088cc;
        }

        .share-button.export-mobile {
            background: rgba(0, 136, 204, 0.15);
            border-color: #0088cc;
            font-size: 12px;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
            flex-direction: column;
            gap: 20px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--neon-blue);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            color: white;
            font-size: 16px;
            text-align: center;
            max-width: 80%;
            animation: pulse 1.5s infinite;
        }

        .status-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2001;
            pointer-events: none;
            max-width: 90%;
            text-align: center;
        }

        .status-message.success {
            background-color: var(--success-green);
            box-shadow: 0 0 15px rgba(0, 200, 81, 0.5);
        }

        .status-message.error {
            background-color: var(--error-red);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
        }

        .status-message.warning {
            background-color: var(--warning-yellow);
            box-shadow: 0 0 15px rgba(255, 187, 51, 0.5);
        }

        .status-message.show {
            opacity: 1;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        @media (max-width: 480px) {
            body {
                padding: 8px;
            }

            .preview-content {
                padding: 15px;
            }

            .preview-content h2 {
                font-size: 18px;
                margin-bottom: 15px;
            }

            .share-button {
                padding: 10px;
                font-size: 12px;
            }

            .status-message {
                font-size: 14px;
                padding: 10px 20px;
            }
        }
    </style>
    </head>
<body>
    <div class="app-container">
        <div class="canvas-wrapper">
            <div class="canvas-container">
                <canvas id="memeCanvas"></canvas>
            </div>
        </div>

        <div class="stogie-selector" id="stogieSelector">
            <div class="stogie-option">
                <img src="images/stogie.png" alt="Stogie 1" data-src="images/stogie.png">
            </div>
            <div class="stogie-option">
                <img src="images/stogie2.png" alt="Stogie 2" data-src="images/stogie2.png">
            </div>
            <div class="stogie-option">
                <img src="images/stogie3.png" alt="Stogie 3" data-src="images/stogie3.png">
            </div>
            <div class="stogie-option">
                <img src="images/glasses.png" alt="Glasses" data-src="images/glasses.png">
            </div>
        </div>

        <div class="control-panel">
            <input type="file" id="fileInput" accept="image/*">
            <button class="button" onclick="document.getElementById('fileInput').click()">
                <i class="fas fa-image"></i> Choose Image
            </button>
            
            <div class="slider-container">
                <label>Rotation</label>
                <input type="range" id="rotationSlider" min="0" max="360" value="180">
            </div>
            
            <div class="slider-container">
                <label>Size</label>
                <input type="range" id="scaleSlider" min="5" max="75" value="37.5">
            </div>

            <button class="button delete-button disabled" id="deleteButton">
                <i class="fas fa-trash"></i> Delete Selected
            </button>

            <button class="button" id="previewButton">
                <i class="fas fa-eye"></i> Preview & Share
            </button>
        </div>
    </div>

    <!-- Enhanced Preview Modal -->
    <div class="preview-modal" id="previewModal">
        <div class="preview-content">
            <button class="modal-close" onclick="closePreview()">×</button>
            <h2>Preview & Share</h2>
            <div class="preview-image-container">
                <img id="previewImage" class="preview-image" alt="Preview">
            </div>
            
            <div class="share-options">
                <button class="share-button export-mobile" onclick="sendToDM()" data-action="dm">
                    <i class="fas fa-mobile-alt"></i> Export (Mobile)
                    <div class="button-loader" style="display: none;"></div>
                </button>
                <button class="share-button download" onclick="downloadImage()" data-action="download">
                    <i class="fas fa-download"></i> Download
                </button>
                <button class="share-button telegram" onclick="shareToTelegram()" data-action="telegram">
                    <i class="fab fa-telegram"></i> Share
                </button>
                <button class="share-button" onclick="shareToOthers()" data-action="others">
                    <i class="fas fa-share-alt"></i> More
                </button>
            </div>
        </div>
    </div>

    <!-- Enhanced Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Processing your meme...</div>
    </div>

    <!-- Status Messages Container -->
    <div class="status-message" id="statusMessage"></div>

    <!-- Enhanced Error Boundary -->
    <div id="errorBoundary" style="display: none;">
        <div class="error-content">
            <h3>Oops! Something went wrong</h3>
            <p id="errorMessage"></p>
            <button onclick="window.location.reload()">Reload App</button>
        </div>
    </div>
    <!-- Security Utils -->
    <script>
        // Security utilities to prevent injection attacks
        const securityUtils = {
            sanitizeInput: function(input) {
                const div = document.createElement('div');
                div.textContent = input;
                return div.innerHTML;
            },
            
            validateImage: function(file) {
                const validTypes = ['image/jpeg', 'image/png', 'image/gif'];
                if (!validTypes.includes(file.type)) {
                    throw new Error('Invalid file type. Please use JPG, PNG, or GIF images.');
                }
                if (file.size > 10 * 1024 * 1024) { // 10MB limit
                    throw new Error('File too large. Please use an image under 10MB.');
                }
                return true;
            },
            
            createSecureObjectURL: function(file) {
                const url = URL.createObjectURL(file);
                setTimeout(() => URL.revokeObjectURL(url), 3600000); // Clean up after 1 hour
                return url;
            }
        };

        // Status message handler
        const statusHandler = {
            show: function(message, type = 'success') {
                const statusEl = document.getElementById('statusMessage');
                statusEl.textContent = message;
                statusEl.className = `status-message ${type} show`;
                setTimeout(() => {
                    statusEl.className = 'status-message';
                }, 3000);
            }
        };

        // Enhanced error handler
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Error: ', msg, url, lineNo, columnNo, error);
            if (!msg.includes('favicon') && !msg.includes('ethereum')) {
                statusHandler.show('An error occurred. Please try again.', 'error');
            }
            return false;
        };

        // Core variables
        const canvas = document.getElementById('memeCanvas');
        const ctx = canvas.getContext('2d');
        const baseImage = new Image();
        let overlays = [];
        let activeOverlay = null;
        let isDragging = false;
        let startX, startY;
        let canvasScale = 1;

        // Prevent Web3 injection attempts
        window.addEventListener('load', function() {
            if (!Object.getOwnPropertyDescriptor(window, 'ethereum')) {
                Object.defineProperty(window, 'ethereum', {
                    value: null,
                    writable: false,
                    configurable: false
                });
            }
        });

        // Enhanced initialization
        function initializeCanvas() {
            try {
                const container = canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                const rect = container.getBoundingClientRect();
                
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                canvasScale = dpr;
                
                drawCanvas();
            } catch (error) {
                console.error('Canvas initialization error:', error);
                statusHandler.show('Error initializing canvas', 'error');
            }
        }

        // Enhanced image processing
        async function processImage(file) {
            try {
                securityUtils.validateImage(file);
                const reader = new FileReader();
                
                return new Promise((resolve, reject) => {
                    reader.onload = function(event) {
                        baseImage.src = event.target.result;
                        baseImage.onload = () => resolve();
                        baseImage.onerror = () => reject(new Error('Failed to load image'));
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsDataURL(file);
                });
            } catch (error) {
                statusHandler.show(error.message, 'error');
                throw error;
            }
        }

        // Image compression utility
        async function compressImageIfNeeded(file, maxSize = 5 * 1024 * 1024) {
            if (file.size <= maxSize) return file;

            try {
                const img = new Image();
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });

                let quality = 0.8;
                let outputBlob;
                
                do {
                    const scale = Math.min(1, Math.sqrt(maxSize / file.size));
                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    const dataUrl = canvas.toDataURL('image/jpeg', quality);
                    const binaryString = atob(dataUrl.split(',')[1]);
                    const bytes = new Uint8Array(binaryString.length);
                    
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    
                    outputBlob = new Blob([bytes], { type: 'image/jpeg' });
                    quality -= 0.1;
                } while (outputBlob.size > maxSize && quality > 0.3);

                URL.revokeObjectURL(img.src);
                return new File([outputBlob], 'compressed-meme.jpg', { type: 'image/jpeg' });
            } catch (error) {
                console.error('Compression failed:', error);
                return file;
            }
        }
    </script>
    <script>
        // Draw canvas functionality
        function drawCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = canvas.width / dpr;
            const displayHeight = canvas.height / dpr;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (baseImage.src) {
                const imgRatio = baseImage.width / baseImage.height;
                const canvasRatio = displayWidth / displayHeight;
                let drawWidth, drawHeight, x, y;

                if (imgRatio > canvasRatio) {
                    drawWidth = displayWidth;
                    drawHeight = displayWidth / imgRatio;
                    x = 0;
                    y = (displayHeight - drawHeight) / 2;
                } else {
                    drawHeight = displayHeight;
                    drawWidth = displayHeight * imgRatio;
                    x = (displayWidth - drawWidth) / 2;
                    y = 0;
                }

                ctx.drawImage(baseImage, x, y, drawWidth, drawHeight);
            }

            overlays.forEach(overlay => drawOverlay(overlay));
        }

        // Draw overlay functionality
        function drawOverlay(overlay) {
            ctx.save();
            const dpr = window.devicePixelRatio || 1;
            const x = overlay.x / dpr;
            const y = overlay.y / dpr;

            ctx.translate(x, y);
            ctx.rotate(overlay.rotation * Math.PI / 180);
            ctx.scale(overlay.scale, overlay.scale);

            ctx.drawImage(
                overlay.image,
                -overlay.image.width / 2,
                -overlay.image.height / 2
            );

            if (overlay === activeOverlay) {
                ctx.strokeStyle = 'var(--neon-pink)';
                ctx.lineWidth = 2 / overlay.scale;
                ctx.strokeRect(
                    -overlay.image.width / 2,
                    -overlay.image.height / 2,
                    overlay.image.width,
                    overlay.image.height
                );
            }

            ctx.restore();
        }

        // Enhanced send to DM functionality
        async function sendToDM() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingText = loadingOverlay.querySelector('.loading-text');
            
            try {
                loadingOverlay.style.display = 'flex';
                loadingText.textContent = 'Processing image...';

                // Generate high-res canvas
                const exportCanvas = await generateHighResCanvas();
                const imageFile = await convertCanvasToFile(exportCanvas);
                
                if (window.Telegram?.WebApp) {
                    loadingText.textContent = 'Sending to chat...';
                    
                    // Compress image if needed
                    const compressedImage = await compressImageIfNeeded(imageFile);
                    
                    // Convert to base64
                    const base64Data = await convertToBase64(compressedImage);
                    
                    // Send to Telegram
                    window.Telegram.WebApp.sendData(JSON.stringify({
                        type: 'dm_image',
                        data: base64Data,
                        filename: 'meme.png',
                        caption: 'Here\'s your meme!',
                        timestamp: Date.now(),
                        meta: {
                            width: exportCanvas.width,
                            height: exportCanvas.height,
                            type: compressedImage.type
                        }
                    }));

                    statusHandler.show('Meme sent successfully!', 'success');
                    closePreview();
                } else {
                    throw new Error('Telegram WebApp is not available');
                }
            } catch (error) {
                console.error('Error sending to DM:', error);
                statusHandler.show('Failed to send image. Please try again.', 'error');
            } finally {
                loadingOverlay.style.display = 'none';
            }
        }

        // Convert to base64 utility
        function convertToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Generate high-res canvas
        async function generateHighResCanvas() {
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            const scale = 2;

            exportCanvas.width = canvas.width * scale;
            exportCanvas.height = canvas.height * scale;

            try {
                exportCtx.scale(scale * canvasScale, scale * canvasScale);
                
                if (baseImage.src) {
                    const dimensions = calculateImageDimensions(baseImage, canvas);
                    exportCtx.drawImage(baseImage, dimensions.x, dimensions.y, 
                                     dimensions.width, dimensions.height);
                }

                overlays.forEach(overlay => {
                    drawOverlayToCanvas(exportCtx, overlay, canvasScale);
                });

                return exportCanvas;
            } catch (error) {
                console.error('Error generating canvas:', error);
                throw new Error('Failed to generate image');
            }
        }

        // Calculate image dimensions
        function calculateImageDimensions(image, canvas) {
            const imgRatio = image.width / image.height;
            const canvasRatio = canvas.width / canvas.height;
            let width, height, x, y;

            if (imgRatio > canvasRatio) {
                width = canvas.width / canvasScale;
                height = (canvas.width / canvasScale) / imgRatio;
                x = 0;
                y = (canvas.height / canvasScale - height) / 2;
            } else {
                height = canvas.height / canvasScale;
                width = (canvas.height / canvasScale) * imgRatio;
                x = (canvas.width / canvasScale - width) / 2;
                y = 0;
            }

            return { width, height, x, y };
        }

        // Draw overlay to canvas
        function drawOverlayToCanvas(ctx, overlay, scale) {
            ctx.save();
            const x = overlay.x / scale;
            const y = overlay.y / scale;
            
            ctx.translate(x, y);
            ctx.rotate(overlay.rotation * Math.PI / 180);
            ctx.scale(overlay.scale, overlay.scale);
            
            ctx.drawImage(
                overlay.image,
                -overlay.image.width / 2,
                -overlay.image.height / 2
            );
            
            ctx.restore();
        }

        // Convert canvas to file
        async function convertCanvasToFile(canvas) {
            try {
                return new Promise((resolve, reject) => {
                    canvas.toBlob(blob => {
                        if (blob) {
                            const file = new File([blob], 'meme.png', { 
                                type: 'image/png',
                                lastModified: Date.now()
                            });
                            resolve(file);
                        } else {
                            reject(new Error('Failed to create image file'));
                        }
                    }, 'image/png', 1.0);
                });
            } catch (error) {
                console.error('Error converting canvas to file:', error);
                throw new Error('Failed to process image');
            }
        }
    </script>
    <script>
        // Event handlers for file input
        document.getElementById('fileInput').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    await processImage(file);
                    drawCanvas();
                } catch (error) {
                    console.error('File processing error:', error);
                    statusHandler.show(error.message, 'error');
                }
            }
        });

        // Stogie selector click handlers
        document.querySelectorAll('.stogie-option').forEach(option => {
            option.addEventListener('click', () => {
                const img = option.querySelector('img');
                if (img) {
                    const overlayImg = new Image();
                    overlayImg.crossOrigin = "Anonymous";
                    overlayImg.src = img.dataset.src;
                    overlayImg.onload = () => {
                        const dpr = window.devicePixelRatio || 1;
                        const overlay = {
                            image: overlayImg,
                            x: (canvas.width / dpr) / 2,
                            y: (canvas.height / dpr) / 2,
                            rotation: 0,
                            scale: 0.2,
                            initialWidth: overlayImg.width,
                            initialHeight: overlayImg.height
                        };
                        overlays.push(overlay);
                        activeOverlay = overlay;
                        document.getElementById('rotationSlider').value = 180;
                        document.getElementById('scaleSlider').value = 37.5;
                        updateDeleteButtonState();
                        drawCanvas();
                    };
                }
            });
        });

        // Touch event handlers
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const pos = getTouchPos(touch);
            
            const clickedOverlay = findClickedOverlay(pos.x, pos.y);
            activeOverlay = clickedOverlay;
            updateDeleteButtonState();
            
            if (clickedOverlay) {
                isDragging = true;
                startX = pos.x - clickedOverlay.x;
                startY = pos.y - clickedOverlay.y;
                
                document.getElementById('rotationSlider').value = clickedOverlay.rotation + 180;
                document.getElementById('scaleSlider').value = clickedOverlay.scale * 100;
            }
            
            drawCanvas();
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!isDragging || !activeOverlay) return;

            const touch = e.touches[0];
            const pos = getTouchPos(touch);
            
            activeOverlay.x = pos.x - startX;
            activeOverlay.y = pos.y - startY;
            drawCanvas();
        }

        function handleTouchEnd() {
            isDragging = false;
        }

        // Mouse event handlers
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);

        function handleMouseDown(e) {
            const pos = getMousePos(e);
            const clickedOverlay = findClickedOverlay(pos.x, pos.y);
            
            activeOverlay = clickedOverlay;
            updateDeleteButtonState();
            
            if (clickedOverlay) {
                isDragging = true;
                startX = pos.x - clickedOverlay.x;
                startY = pos.y - clickedOverlay.y;
                
                document.getElementById('rotationSlider').value = clickedOverlay.rotation + 180;
                document.getElementById('scaleSlider').value = clickedOverlay.scale * 100;
            }
            
            drawCanvas();
        }

        function handleMouseMove(e) {
            if (!isDragging || !activeOverlay) return;

            const pos = getMousePos(e);
            activeOverlay.x = pos.x - startX;
            activeOverlay.y = pos.y - startY;
            drawCanvas();
        }

        function handleMouseUp() {
            isDragging = false;
        }

        // Position calculation helpers
        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            return {
                x: (touch.clientX - rect.left) * dpr,
                y: (touch.clientY - rect.top) * dpr
            };
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            return {
                x: (e.clientX - rect.left) * dpr,
                y: (e.clientY - rect.top) * dpr
            };
        }

        // Find clicked overlay with improved hit detection
        function findClickedOverlay(x, y) {
            const dpr = window.devicePixelRatio || 1;
            const clicked = overlays.slice().reverse().find(overlay => {
                const dx = (x - overlay.x);
                const dy = (y - overlay.y);
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (overlay.image.width * overlay.scale * dpr / 2);
            });
            return clicked || null;
        }

        // Slider event handlers
        document.getElementById('rotationSlider').addEventListener('input', e => {
            if (activeOverlay) {
                const sliderValue = parseInt(e.target.value);
                activeOverlay.rotation = sliderValue - 180;
                drawCanvas();
            }
        });

        document.getElementById('scaleSlider').addEventListener('input', e => {
            if (activeOverlay) {
                const scaleValue = parseInt(e.target.value);
                activeOverlay.scale = scaleValue / 100;
                drawCanvas();
            }
        });

        // Delete button handler
        document.getElementById('deleteButton').addEventListener('click', () => {
            if (activeOverlay) {
                overlays = overlays.filter(overlay => overlay !== activeOverlay);
                activeOverlay = null;
                updateDeleteButtonState();
                drawCanvas();
                
                document.getElementById('rotationSlider').value = 180;
                document.getElementById('scaleSlider').value = 37.5;
            }
        });

        // Preview button handler
        document.getElementById('previewButton').addEventListener('click', async () => {
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.style.display = 'flex';
            
            try {
                const exportCanvas = await generateHighResCanvas();
                const previewImage = document.getElementById('previewImage');
                previewImage.src = exportCanvas.toDataURL('image/png');
                document.getElementById('previewModal').style.display = 'flex';
            } catch (error) {
                console.error('Preview generation failed:', error);
                statusHandler.show('Error generating preview', 'error');
            } finally {
                loadingOverlay.style.display = 'none';
            }
        });

        // Share handlers
        function downloadImage() {
            shareImage('download');
        }

        function shareToTelegram() {
            shareImage('telegram');
        }

        function shareToOthers() {
            shareImage('share');
        }

        function closePreview() {
            document.getElementById('previewModal').style.display = 'none';
            if (window.Telegram?.WebApp) {
                window.Telegram.WebApp.BackButton.hide();
            }
        }

        function updateDeleteButtonState() {
            const deleteButton = document.getElementById('deleteButton');
            deleteButton.classList.toggle('disabled', !activeOverlay);
        }

        // Initialize application
        window.addEventListener('load', function() {
            initializeCanvas();
            
            if (window.Telegram?.WebApp) {
                const webapp = window.Telegram.WebApp;
                webapp.ready();
                
                if (webapp.themeParams) {
                    document.documentElement.style.setProperty('--dark-bg', webapp.themeParams.secondary_bg_color);
                    document.documentElement.style.setProperty('--neon-blue', webapp.themeParams.button_color);
                }
                
                webapp.MainButton.setText('Export Meme');
                webapp.MainButton.onClick(sendToDM);
                
                // Handle back button for modal
                webapp.BackButton.onClick(() => {
                    if (document.getElementById('previewModal').style.display === 'flex') {
                        closePreview();
                    } else {
                        webapp.close();
                    }
                });
            }
        });

        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (activeOverlay) {
                switch(e.key) {
                    case 'Delete':
                    case 'Backspace':
                        document.getElementById('deleteButton').click();
                        break;
                    case 'Escape':
                        activeOverlay = null;
                        updateDeleteButtonState();
                        drawCanvas();
                        break;
                }
            }
            
            if (e.key === 'Escape' && document.getElementById('previewModal').style.display === 'flex') {
                closePreview();
            }
        });

        // Handle window resizing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                initializeCanvas();
                drawCanvas();
            }, 250);
        });
    </script>
</body>
</html>

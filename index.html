<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Enhanced Meme Maker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- Security headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://cdnjs.cloudflare.com data: blob:; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; img-src 'self' data: blob: https://*;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,">
    
    <!-- Telegram WebApp script -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body data-platform="mobile">
    <div class="app-container">
        <div class="canvas-wrapper">
            <div class="canvas-container">
                <canvas id="memeCanvas"></canvas>
            </div>
        </div>

        <div class="stogie-selector" id="stogieSelector">
            <!-- Enhanced stogie options with data attributes -->
            <div class="stogie-option" data-type="stogie">
                <img src="images/stogie.png" alt="Stogie 1" data-src="images/stogie.png">
            </div>
            <div class="stogie-option" data-type="stogie">
                <img src="images/stogie2.png" alt="Stogie 2" data-src="images/stogie2.png">
            </div>
            <div class="stogie-option" data-type="stogie">
                <img src="images/stogie3.png" alt="Stogie 3" data-src="images/stogie3.png">
            </div>
            <div class="stogie-option" data-type="accessory">
                <img src="images/glasses.png" alt="Glasses" data-src="images/glasses.png">
            </div>
        </div>

        <div class="control-panel">
            <input type="file" id="fileInput" accept="image/*">
            <button class="button" onclick="document.getElementById('fileInput').click()">
                <i class="fas fa-image"></i> Choose Image
            </button>
            
            <div class="slider-container">
                <label>Rotation</label>
                <input type="range" id="rotationSlider" min="0" max="360" value="180">
            </div>
            
            <div class="slider-container">
                <label>Size</label>
                <input type="range" id="scaleSlider" min="5" max="75" value="37.5">
            </div>

            <button class="button delete-button disabled" id="deleteButton">
                <i class="fas fa-trash"></i> Delete Selected
            </button>

            <button class="button" id="previewButton">
                <i class="fas fa-eye"></i> Preview & Share
            </button>
        </div>
    </div>

    <!-- Enhanced Preview Modal -->
    <div class="preview-modal" id="previewModal">
        <div class="preview-content">
            <h2>Preview & Share</h2>
            <div class="preview-image-container">
                <img id="previewImage" class="preview-image" alt="Preview">
            </div>
            
            <div class="share-options">
                <button class="share-button download" onclick="downloadImage()" data-action="download">
                    <i class="fas fa-download"></i> Download
                </button>
                <button class="share-button" onclick="copyToClipboard()" data-action="copy">
                    <i class="fas fa-copy"></i> Copy to Clipboard
                </button>
                <button class="share-button" onclick="shareToSocial()" data-action="social">
                    <i class="fas fa-share-alt"></i> Share
                </button>
            </div>
        </div>
    </div>

    <!-- Mobile Redirect Modal -->
    <div class="mobile-redirect-modal" id="mobileRedirectModal">
        <div class="modal-content">
            <h2>Better Experience Available!</h2>
            <p>For full access to all features including downloading and sharing, please open this app in your mobile browser.</p>
            <button class="button" id="openInBrowserButton">
                <i class="fas fa-external-link-alt"></i> Open in Browser
            </button>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Processing your meme...</div>
    </div>

    <!-- Status Messages Container -->
    <div class="status-message" id="statusMessage"></div>

<style>
        :root {
            --neon-pink: #ff71ce;
            --neon-blue: #01cdfe;
            --neon-purple: #b967ff;
            --neon-green: #05ffa1;
            --dark-bg: #1a1a2e;
            --grid-color: rgba(255, 113, 206, 0.1);
            --modal-bg: rgba(26, 26, 46, 0.95);
            --error-red: #ff4444;
            --success-green: #00C851;
            --warning-yellow: #ffbb33;
            --retrowave-gradient: linear-gradient(
                45deg,
                var(--neon-pink),
                var(--neon-purple),
                var(--neon-blue)
            );
            --telegram-blue: #0088cc;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: manipulation;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto;
            margin: 0;
            padding: 16px;
            background-color: var(--dark-bg);
            color: white;
            min-height: 100vh;
            overscroll-behavior: none;
            position: relative;
        }

        .app-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 0;
            position: relative;
            z-index: 1;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            padding-top: 75%;
            margin-bottom: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 15px var(--neon-blue);
            overflow: hidden;
        }

        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            background: #000;
        }

        #memeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            display: block;
        }

        .stogie-selector {
            width: 100%;
            margin: 8px 0;
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--neon-pink);
            border-radius: 12px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 0 10px var(--neon-pink);
            backdrop-filter: blur(5px);
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .stogie-selector::-webkit-scrollbar {
            display: none;
        }

        .stogie-option {
            flex: 0 0 80px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--neon-purple);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 5px;
            position: relative;
        }

        .stogie-option:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        .stogie-option img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 12px;
            margin: 8px 0;
            border: 1px solid var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
            backdrop-filter: blur(5px);
        }

        .button {
            background: var(--retrowave-gradient);
            color: white;
            border: none;
            padding: 16px 20px;
            border-radius: 8px;
            font-size: 16px;
            width: 100%;
            margin-bottom: 12px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        .button:active {
            transform: scale(0.98);
        }

        .button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }

        .delete-button {
            background: linear-gradient(45deg, #ff0844, #ffb199);
        }

        .delete-button.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .slider-container {
            margin: 16px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 8px;
            color: var(--neon-pink);
            text-transform: uppercase;
            font-size: 14px;
            letter-spacing: 1px;
        }

        input[type="range"] {
            width: 100%;
            height: 36px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            outline: none;
            border: 1px solid var(--neon-blue);
            margin: 0;
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: var(--neon-purple);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--neon-purple);
            border: none;
            margin-top: -8px;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            border: none;
        }

        #fileInput {
            display: none;
        }

        .preview-modal, .mobile-redirect-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--modal-bg);
            z-index: 1000;
            padding: 20px;
            backdrop-filter: blur(10px);
            touch-action: none;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .mobile-redirect-modal {
            z-index: 2000;
        }

        .preview-content, .modal-content {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 20px var(--neon-blue);
            position: relative;
        }

        .mobile-redirect-modal .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .preview-content h2, .modal-content h2 {
            margin: 0 0 20px 0;
            text-align: center;
            color: var(--neon-pink);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 20px;
        }

        .preview-image-container {
            width: 100%;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
        }

        .preview-image {
            width: 100%;
            display: block;
            border-radius: 8px;
        }

        .modal-content p {
            color: white;
            margin-bottom: 20px;
            line-height: 1.5;
            font-size: 16px;
        }

        .share-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .share-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--neon-purple);
            color: white;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .share-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .share-button:active {
            transform: translateY(0);
        }

        .share-button.download {
            border-color: var(--neon-green);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
            flex-direction: column;
            gap: 20px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--neon-blue);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            color: white;
            font-size: 16px;
            text-align: center;
            max-width: 80%;
            animation: pulse 1.5s infinite;
        }

        .status-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2001;
            pointer-events: none;
            max-width: 90%;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .status-message.show {
            opacity: 1;
        }

        .status-message.success {
            background-color: var(--success-green);
            box-shadow: 0 0 15px rgba(0, 200, 81, 0.5);
        }

        .status-message.error {
            background-color: var(--error-red);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
        }

        .status-message.warning {
            background-color: var(--warning-yellow);
            box-shadow: 0 0 15px rgba(255, 187, 51, 0.5);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        @media (max-width: 480px) {
            body {
                padding: 8px;
            }

            .preview-content {
                padding: 15px;
            }

            .preview-content h2 {
                font-size: 18px;
                margin-bottom: 15px;
            }

            .share-button {
                padding: 10px;
                font-size: 12px;
            }

            .status-message {
                font-size: 14px;
                padding: 10px 20px;
            }
        }
    </style>
    <script>
// Security and Platform Utils
const platformUtils = {
    isTelegram: Boolean(window.Telegram?.WebApp),
    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
    
    init: function() {
        // Add console logs for debugging
        console.log('Platform detection:', {
            isTelegram: this.isTelegram,
            isMobile: this.isMobile
        });

        // Set platform attribute on body
        document.body.setAttribute('data-platform', this.isMobile ? 'mobile' : 'pc');
        
        // Show mobile redirect if in Telegram mobile
        if (this.isTelegram && this.isMobile) {
            console.log('Showing mobile redirect');
            this.showMobileRedirectPrompt();
        } else {
            this.setupEnvironment();
        }
    },

    setupEnvironment: function() {
        if (this.isTelegram) {
            console.log('Setting up Telegram features');
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
        }
    },

    showMobileRedirectPrompt: function() {
        const modal = document.getElementById('mobileRedirectModal');
        if (!modal) {
            console.error('Mobile redirect modal not found');
            return;
        }
        modal.style.display = 'block';
        
        const button = document.getElementById('openInBrowserButton');
        if (button) {
            button.onclick = () => {
                // Get current URL without query parameters
                const cleanUrl = window.location.origin + window.location.pathname;
                // Open in new tab
                window.open(cleanUrl, '_blank');
            };
        }
    }
};

// Enhanced security utilities
const securityUtils = {
    sanitizeInput: function(input) {
        const div = document.createElement('div');
        div.textContent = input;
        return div.innerHTML;
    },
    
    validateImage: function(file) {
        const validTypes = ['image/jpeg', 'image/png', 'image/gif'];
        if (!validTypes.includes(file.type)) {
            throw new Error('Invalid file type. Please use JPG, PNG, or GIF images.');
        }
        if (file.size > 10 * 1024 * 1024) { // 10MB limit
            throw new Error('File too large. Please use an image under 10MB.');
        }
        return true;
    },
    
    createSecureObjectURL: function(file) {
        const url = URL.createObjectURL(file);
        setTimeout(() => URL.revokeObjectURL(url), 3600000); // Clean up after 1 hour
        return url;
    }
};

// Enhanced status handling
const statusHandler = {
    show: function(message, type = 'success', duration = 3000) {
        const statusEl = document.getElementById('statusMessage');
        statusEl.textContent = message;
        statusEl.className = `status-message ${type} show`;
        
        setTimeout(() => {
            statusEl.className = 'status-message';
        }, duration);
    },

    showProgress: function(message) {
        const statusEl = document.getElementById('statusMessage');
        statusEl.textContent = message;
        statusEl.className = 'status-message progress show';
    }
};

// Enhanced loading overlay handler
const loadingHandler = {
    show: function(message = 'Processing...') {
        const overlay = document.getElementById('loadingOverlay');
        const text = overlay.querySelector('.loading-text');
        text.textContent = message;
        overlay.style.display = 'flex';
    },
    
    hide: function() {
        document.getElementById('loadingOverlay').style.display = 'none';
    },

    updateMessage: function(message) {
        const text = document.getElementById('loadingOverlay').querySelector('.loading-text');
        text.textContent = message;
    }
};

// Enhanced error handler
const errorHandler = {
    handle: function(error, context = '') {
        console.error(`Error in ${context}:`, error);
        
        const errorMessage = error.message || 'An error occurred. Please try again.';
        statusHandler.show(errorMessage, 'error');
        
        if (platformUtils.isPC) {
            console.debug('Detailed error info:', error);
        }
        
        loadingHandler.hide();
    },

    logError: function(error, context) {
        console.error(`[${context}] Error:`, error);
        if (error.stack) {
            console.error('Stack trace:', error.stack);
        }
    }
};

// Core variables
const canvas = document.getElementById('memeCanvas');
const ctx = canvas.getContext('2d');
const baseImage = new Image();
let overlays = [];
let activeOverlay = null;
let isDragging = false;
let startX, startY;
let canvasScale = 1;

// Debug utilities
const debugUtils = {
    enabled: false,
    
    log: function(message, data = null) {
        if (!this.enabled) return;
        console.log(`[Debug] ${message}`, data || '');
        this.updateDebugPanel();
    },
    
    updateDebugPanel: function() {
        if (!this.enabled) return;
        const debugInfo = document.getElementById('debugInfo');
        if (debugInfo) {
            debugInfo.textContent = JSON.stringify({
                platformInfo: {
                    isTelegram: platformUtils.isTelegram,
                    isMobile: platformUtils.isMobile
                },
                canvasInfo: {
                    width: canvas.width,
                    height: canvas.height,
                    scale: canvasScale
                },
                overlaysCount: overlays.length,
                activeOverlay: Boolean(activeOverlay)
            }, null, 2);
        }
    }
};
</script>
<script>
// Canvas initialization and utilities
const canvasUtils = {
    init: function() {
        try {
            debugUtils.log('Initializing canvas');
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvasScale = dpr;
            
            debugUtils.log('Canvas initialized', {
                width: canvas.width,
                height: canvas.height,
                dpr: dpr
            });
            
            this.draw();
        } catch (error) {
            errorHandler.handle(error, 'canvas initialization');
        }
    },

    draw: function() {
        try {
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = canvas.width / dpr;
            const displayHeight = canvas.height / dpr;

            // Clear and set background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw base image if exists
            if (baseImage.src) {
                this.drawBaseImage(displayWidth, displayHeight);
            }

            // Draw overlays
            overlays.forEach(overlay => this.drawOverlay(overlay));
            
            debugUtils.log('Canvas redrawn', {
                overlaysCount: overlays.length,
                hasBaseImage: Boolean(baseImage.src)
            });
        } catch (error) {
            errorHandler.handle(error, 'canvas drawing');
        }
    },

    drawBaseImage: function(displayWidth, displayHeight) {
        const imgRatio = baseImage.width / baseImage.height;
        const canvasRatio = displayWidth / displayHeight;
        let drawWidth, drawHeight, x, y;

        if (imgRatio > canvasRatio) {
            drawWidth = displayWidth;
            drawHeight = displayWidth / imgRatio;
            x = 0;
            y = (displayHeight - drawHeight) / 2;
        } else {
            drawHeight = displayHeight;
            drawWidth = displayHeight * imgRatio;
            x = (displayWidth - drawWidth) / 2;
            y = 0;
        }

        ctx.drawImage(baseImage, x, y, drawWidth, drawHeight);
        debugUtils.log('Base image drawn', { width: drawWidth, height: drawHeight });
    },

    drawOverlay: function(overlay) {
        ctx.save();
        const dpr = window.devicePixelRatio || 1;
        const x = overlay.x / dpr;
        const y = overlay.y / dpr;

        ctx.translate(x, y);
        ctx.rotate(overlay.rotation * Math.PI / 180);
        ctx.scale(overlay.scale, overlay.scale);

        ctx.drawImage(
            overlay.image,
            -overlay.image.width / 2,
            -overlay.image.height / 2
        );

        if (overlay === activeOverlay) {
            this.drawOverlayBorder(overlay);
        }

        ctx.restore();
    },

    drawOverlayBorder: function(overlay) {
        ctx.strokeStyle = 'var(--neon-pink)';
        ctx.lineWidth = 2 / overlay.scale;
        ctx.strokeRect(
            -overlay.image.width / 2,
            -overlay.image.height / 2,
            overlay.image.width,
            overlay.image.height
        );
    }
};

// Enhanced image processing utilities
const imageUtils = {
    processImage: async function(file) {
        try {
            debugUtils.log('Processing new image');
            securityUtils.validateImage(file);
            
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = () => {
                    baseImage.src = reader.result;
                    baseImage.onload = () => {
                        debugUtils.log('Image loaded successfully', {
                            width: baseImage.width,
                            height: baseImage.height
                        });
                        resolve();
                    };
                    baseImage.onerror = () => reject(new Error('Failed to load image'));
                };
                
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });
        } catch (error) {
            errorHandler.handle(error, 'image processing');
            throw error;
        }
    },

    compressImage: async function(file, maxSize = 5 * 1024 * 1024) {
        debugUtils.log('Starting image compression', { originalSize: file.size });
        
        if (file.size <= maxSize) {
            debugUtils.log('No compression needed');
            return file;
        }

        try {
            const img = new Image();
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });

            let quality = 0.8;
            let outputBlob;
            
            do {
                const scale = Math.min(1, Math.sqrt(maxSize / file.size));
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
                
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                const dataUrl = canvas.toDataURL('image/jpeg', quality);
                const binaryString = atob(dataUrl.split(',')[1]);
                const bytes = new Uint8Array(binaryString.length);
                
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                outputBlob = new Blob([bytes], { type: 'image/jpeg' });
                quality -= 0.1;
            } while (outputBlob.size > maxSize && quality > 0.3);

            URL.revokeObjectURL(img.src);
            
            debugUtils.log('Compression complete', {
                originalSize: file.size,
                compressedSize: outputBlob.size
            });
            
            return new File([outputBlob], 'compressed-meme.jpg', { type: 'image/jpeg' });
        } catch (error) {
            errorHandler.logError(error, 'image compression');
            debugUtils.log('Compression failed, returning original file');
            return file;
        }
    }
};
</script>
<script>
// Enhanced sharing functionality
const sharingUtils = {
    async generateHighResCanvas() {
        debugUtils.log('Generating high-res canvas');
        const exportCanvas = document.createElement('canvas');
        const exportCtx = exportCanvas.getContext('2d');
        const scale = 2;

        exportCanvas.width = canvas.width * scale;
        exportCanvas.height = canvas.height * scale;

        try {
            exportCtx.scale(scale * canvasScale, scale * canvasScale);
            
            if (baseImage.src) {
                const dimensions = this.calculateImageDimensions();
                exportCtx.drawImage(baseImage, dimensions.x, dimensions.y, 
                                 dimensions.width, dimensions.height);
            }

            overlays.forEach(overlay => {
                this.drawOverlayToCanvas(exportCtx, overlay, canvasScale);
            });

            debugUtils.log('High-res canvas generated', {
                width: exportCanvas.width,
                height: exportCanvas.height
            });

            return exportCanvas;
        } catch (error) {
            errorHandler.handle(error, 'generating high-res canvas');
            throw new Error('Failed to generate image');
        }
    },

    calculateImageDimensions() {
        const imgRatio = baseImage.width / baseImage.height;
        const canvasRatio = canvas.width / canvas.height;
        let width, height, x, y;

        if (imgRatio > canvasRatio) {
            width = canvas.width / canvasScale;
            height = (canvas.width / canvasScale) / imgRatio;
            x = 0;
            y = (canvas.height / canvasScale - height) / 2;
        } else {
            height = canvas.height / canvasScale;
            width = (canvas.height / canvasScale) * imgRatio;
            x = (canvas.width / canvasScale - width) / 2;
            y = 0;
        }

        return { width, height, x, y };
    },

    drawOverlayToCanvas(ctx, overlay, scale) {
        ctx.save();
        const x = overlay.x / scale;
        const y = overlay.y / scale;
        
        ctx.translate(x, y);
        ctx.rotate(overlay.rotation * Math.PI / 180);
        ctx.scale(overlay.scale, overlay.scale);
        
        ctx.drawImage(
            overlay.image,
            -overlay.image.width / 2,
            -overlay.image.height / 2
        );
        
        ctx.restore();
    },

    async convertCanvasToFile(canvas) {
        try {
            return new Promise((resolve, reject) => {
                canvas.toBlob(blob => {
                    if (blob) {
                        const file = new File([blob], 'meme.png', { 
                            type: 'image/png',
                            lastModified: Date.now()
                        });
                        resolve(file);
                    } else {
                        reject(new Error('Failed to create image file'));
                    }
                }, 'image/png', 1.0);
            });
        } catch (error) {
            errorHandler.handle(error, 'converting canvas to file');
            throw error;
        }
    }
};

// Sharing functions
async function downloadImage() {
    loadingHandler.show('Preparing download...');
    
    try {
        const exportCanvas = await sharingUtils.generateHighResCanvas();
        const imageFile = await sharingUtils.convertCanvasToFile(exportCanvas);
        
        const url = URL.createObjectURL(imageFile);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'meme.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        statusHandler.show('Image downloaded successfully!', 'success');
    } catch (error) {
        errorHandler.handle(error, 'downloading image');
    } finally {
        loadingHandler.hide();
    }
}

async function copyToClipboard() {
    loadingHandler.show('Copying to clipboard...');
    
    try {
        const exportCanvas = await sharingUtils.generateHighResCanvas();
        const blob = await new Promise(resolve => exportCanvas.toBlob(resolve));
        
        await navigator.clipboard.write([
            new ClipboardItem({
                [blob.type]: blob
            })
        ]);
        
        statusHandler.show('Copied to clipboard!', 'success');
    } catch (error) {
        errorHandler.handle(error, 'copying to clipboard');
    } finally {
        loadingHandler.hide();
    }
}

async function shareToSocial() {
    loadingHandler.show('Preparing to share...');
    
    try {
        const exportCanvas = await sharingUtils.generateHighResCanvas();
        const imageFile = await sharingUtils.convertCanvasToFile(exportCanvas);
        
        if (navigator.share) {
            await navigator.share({
                files: [imageFile],
                title: 'Check out my meme!',
                text: 'Created with Meme Maker'
            });
            statusHandler.show('Shared successfully!', 'success');
        } else {
            // Fallback to download if sharing is not supported
            downloadImage();
        }
    } catch (error) {
        if (error.name !== 'AbortError') {
            errorHandler.handle(error, 'sharing to social');
        }
    } finally {
        loadingHandler.hide();
    }
}

// Event Handlers
document.getElementById('fileInput').addEventListener('change', async function(e) {
    const file = e.target.files[0];
    if (file) {
        loadingHandler.show('Processing image...');
        try {
            await imageUtils.processImage(file);
            canvasUtils.draw();
            statusHandler.show('Image loaded successfully!', 'success');
        } catch (error) {
            errorHandler.handle(error, 'file input');
        } finally {
            loadingHandler.hide();
        }
    }
});

// Initialize everything when the window loads
window.addEventListener('load', function() {
    debugUtils.log('Window loaded, initializing app');
    platformUtils.init();
    canvasUtils.init();
});
</script>
<script>
// Stogie selector handlers
document.querySelectorAll('.stogie-option').forEach(option => {
    option.addEventListener('click', () => {
        const img = option.querySelector('img');
        if (img) {
            debugUtils.log('Stogie option clicked', {
                src: img.dataset.src,
                type: option.dataset.type
            });

            const overlayImg = new Image();
            overlayImg.crossOrigin = "Anonymous";
            overlayImg.src = img.dataset.src;
            
            overlayImg.onload = () => {
                const dpr = window.devicePixelRatio || 1;
                const overlay = {
                    image: overlayImg,
                    x: (canvas.width / dpr) / 2,
                    y: (canvas.height / dpr) / 2,
                    rotation: 0,
                    scale: 0.2,
                    initialWidth: overlayImg.width,
                    initialHeight: overlayImg.height,
                    type: option.dataset.type
                };
                
                overlays.push(overlay);
                activeOverlay = overlay;
                document.getElementById('rotationSlider').value = 180;
                document.getElementById('scaleSlider').value = 37.5;
                updateDeleteButtonState();
                canvasUtils.draw();
                
                debugUtils.log('Overlay added', {
                    totalOverlays: overlays.length,
                    overlayDimensions: {
                        width: overlayImg.width,
                        height: overlayImg.height
                    }
                });
            };

            overlayImg.onerror = () => {
                errorHandler.handle(new Error('Failed to load overlay image'), 'loading overlay');
            };
        }
    });
});

// Touch event handlers
canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd);

function handleTouchStart(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const pos = getTouchPos(touch);
    
    const clickedOverlay = findClickedOverlay(pos.x, pos.y);
    if (activeOverlay !== clickedOverlay) {
        activeOverlay = clickedOverlay;
        updateDeleteButtonState();
        canvasUtils.draw();
    }
    
    if (clickedOverlay) {
        isDragging = true;
        startX = pos.x - clickedOverlay.x;
        startY = pos.y - clickedOverlay.y;
        
        document.getElementById('rotationSlider').value = clickedOverlay.rotation + 180;
        document.getElementById('scaleSlider').value = clickedOverlay.scale * 100;
        
        debugUtils.log('Touch started on overlay', {
            position: { x: pos.x, y: pos.y },
            overlayType: clickedOverlay.type
        });
    }
}

function handleTouchMove(e) {
    e.preventDefault();
    if (!isDragging || !activeOverlay) return;

    const touch = e.touches[0];
    const pos = getTouchPos(touch);
    
    activeOverlay.x = pos.x - startX;
    activeOverlay.y = pos.y - startY;
    
    canvasUtils.draw();
}

function handleTouchEnd() {
    if (isDragging) {
        debugUtils.log('Touch ended', {
            finalPosition: activeOverlay ? {
                x: activeOverlay.x,
                y: activeOverlay.y
            } : null
        });
    }
    isDragging = false;
}

// Mouse event handlers
canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);

function handleMouseDown(e) {
    const pos = getMousePos(e);
    const clickedOverlay = findClickedOverlay(pos.x, pos.y);
    
    if (activeOverlay !== clickedOverlay) {
        activeOverlay = clickedOverlay;
        updateDeleteButtonState();
        canvasUtils.draw();
    }
    
    if (clickedOverlay) {
        isDragging = true;
        startX = pos.x - clickedOverlay.x;
        startY = pos.y - clickedOverlay.y;
        
        document.getElementById('rotationSlider').value = clickedOverlay.rotation + 180;
        document.getElementById('scaleSlider').value = clickedOverlay.scale * 100;
        
        debugUtils.log('Mouse down on overlay', {
            position: { x: pos.x, y: pos.y },
            overlayType: clickedOverlay.type
        });
    }
}

function handleMouseMove(e) {
    if (!isDragging || !activeOverlay) return;

    const pos = getMousePos(e);
    activeOverlay.x = pos.x - startX;
    activeOverlay.y = pos.y - startY;
    
    canvasUtils.draw();
}

function handleMouseUp() {
    if (isDragging) {
        debugUtils.log('Mouse up', {
            finalPosition: activeOverlay ? {
                x: activeOverlay.x,
                y: activeOverlay.y
            } : null
        });
    }
    isDragging = false;
}

// Utility functions for position calculations
function getTouchPos(touch) {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    return {
        x: (touch.clientX - rect.left) * dpr,
        y: (touch.clientY - rect.top) * dpr
    };
}

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    return {
        x: (e.clientX - rect.left) * dpr,
        y: (e.clientY - rect.top) * dpr
    };
}

function findClickedOverlay(x, y) {
    const dpr = window.devicePixelRatio || 1;
    return overlays.slice().reverse().find(overlay => {
        const dx = (x - overlay.x);
        const dy = (y - overlay.y);
        const distance = Math.sqrt(dx * dx + dy * dy);
        const hitboxSize = overlay.image.width * overlay.scale * dpr / 2;
        return distance < hitboxSize;
    }) || null;
}

// Slider handlers
document.getElementById('rotationSlider').addEventListener('input', e => {
    if (activeOverlay) {
        const sliderValue = parseInt(e.target.value);
        activeOverlay.rotation = sliderValue - 180;
        canvasUtils.draw();
        
        debugUtils.log('Rotation updated', {
            newRotation: activeOverlay.rotation
        });
    }
});

document.getElementById('scaleSlider').addEventListener('input', e => {
    if (activeOverlay) {
        const scaleValue = parseInt(e.target.value);
        activeOverlay.scale = scaleValue / 100;
        canvasUtils.draw();
        
        debugUtils.log('Scale updated', {
            newScale: activeOverlay.scale
        });
    }
});

// Delete button handler
document.getElementById('deleteButton').addEventListener('click', () => {
    if (activeOverlay) {
        debugUtils.log('Deleting overlay', {
            type: activeOverlay.type,
            position: { x: activeOverlay.x, y: activeOverlay.y }
        });

        overlays = overlays.filter(overlay => overlay !== activeOverlay);
        activeOverlay = null;
        updateDeleteButtonState();
        canvasUtils.draw();
        
        document.getElementById('rotationSlider').value = 180;
        document.getElementById('scaleSlider').value = 37.5;
        
        statusHandler.show('Item deleted', 'success');
    }
});

// Preview button handler
document.getElementById('previewButton').addEventListener('click', async () => {
    loadingHandler.show('Generating preview...');
    
    try {
        debugUtils.log('Generating preview');
        const exportCanvas = await sharingUtils.generateHighResCanvas();
        const previewImage = document.getElementById('previewImage');
        previewImage.src = exportCanvas.toDataURL('image/png');
        document.getElementById('previewModal').style.display = 'flex';
    } catch (error) {
        errorHandler.handle(error, 'generating preview');
    } finally {
        loadingHandler.hide();
    }
});

function updateDeleteButtonState() {
    const deleteButton = document.getElementById('deleteButton');
    deleteButton.classList.toggle('disabled', !activeOverlay);
    debugUtils.log('Delete button state updated', {
        isEnabled: Boolean(activeOverlay)
    });
}

function closePreview() {
    document.getElementById('previewModal').style.display = 'none';
}

// Window event handlers
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        debugUtils.log('Window resized');
        canvasUtils.init();
    }, 250);
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if (activeOverlay) {
        switch(e.key) {
            case 'Delete':
            case 'Backspace':
                document.getElementById('deleteButton').click();
                break;
            case 'Escape':
                activeOverlay = null;
                updateDeleteButtonState();
                canvasUtils.draw();
                break;
        }
    }
    
    if (e.key === 'Escape' && document.getElementById('previewModal').style.display === 'flex') {
        closePreview();
    }
});
</script>
</body>
</html>

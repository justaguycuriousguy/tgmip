<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Enhanced Meme Maker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- Security headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://cdnjs.cloudflare.com data: blob:; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://telegram.org; img-src 'self' data: blob: https://*;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,">
    
    <!-- Telegram WebApp script -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body data-platform="mobile">
    <div class="app-container">
        <div class="canvas-wrapper">
            <div class="canvas-container">
                <canvas id="memeCanvas"></canvas>
            </div>
        </div>

        <div class="stogie-selector" id="stogieSelector">
            <div class="stogie-option" data-type="stogie">
                <img src="images/stogie.png" alt="Stogie 1" data-src="images/stogie.png">
            </div>
            <div class="stogie-option" data-type="stogie">
                <img src="images/stogie2.png" alt="Stogie 2" data-src="images/stogie2.png">
            </div>
            <div class="stogie-option" data-type="stogie">
                <img src="images/stogie3.png" alt="Stogie 3" data-src="images/stogie3.png">
            </div>
            <div class="stogie-option" data-type="accessory">
                <img src="images/glasses.png" alt="Glasses" data-src="images/glasses.png">
            </div>
        </div>

        <div class="control-panel">
            <input type="file" id="fileInput" accept="image/*">
            <button class="button" onclick="document.getElementById('fileInput').click()">
                <i class="fas fa-image"></i> Choose Image
            </button>
            
            <div class="slider-container">
                <label>Rotation</label>
                <input type="range" id="rotationSlider" min="0" max="360" value="180">
            </div>
            
            <div class="slider-container">
                <label>Size</label>
                <input type="range" id="scaleSlider" min="5" max="75" value="37.5">
            </div>

            <button class="button delete-button disabled" id="deleteButton">
                <i class="fas fa-trash"></i> Delete Selected
            </button>

            <button class="button" id="previewButton">
                <i class="fas fa-eye"></i> Preview & Share
            </button>
        </div>
    </div>

    <!-- Enhanced Preview Modal -->
    <div class="preview-modal" id="previewModal">
        <div class="preview-content">
            <h2>Preview & Share</h2>
            <div class="preview-image-container">
                <img id="previewImage" class="preview-image" alt="Preview">
            </div>
            
            <div class="share-options">
                <button class="share-button download" onclick="downloadImage()" data-action="download">
                    <i class="fas fa-download"></i> Download
                </button>
                <button class="share-button" onclick="copyToClipboard()" data-action="copy">
                    <i class="fas fa-copy"></i> Copy to Clipboard
                </button>
                <button class="share-button" onclick="shareToSocial()" data-action="social">
                    <i class="fas fa-share-alt"></i> Share
                </button>
            </div>
        </div>
    </div>

    <!-- Instruction Overlay -->
    <div class="instruction-overlay" id="instructionOverlay">
        <div class="instruction-content">
            <div class="step-1">
                <div class="custom-arrow">
                    <svg viewBox="0 0 50 50">
                        <path d="M10 40 L40 10 M30 10 L40 10 L40 20" />
                    </svg>
                </div>
                <div class="instruction-text">
                    To enable downloading, copying and sharing, tap the three dots (‚ãÆ) in the top right corner! ‚ú®
                    <button class="got-it-btn" onclick="showStep2()">Got it! üëç</button>
                    <button class="skip-btn" onclick="skipInstructions()">I've already done this ‚úÖ</button>
                </div>
            </div>
            
            <div class="step-2">
                <div class="instruction-text">
                    Perfect! Now select "Open in Browser" to continue with full features enabled! üöÄ
                    <button class="got-it-btn" onclick="closeInstructions()">Let's go!</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Processing your meme...</div>
    </div>

    <!-- Status Messages Container -->
    <div class="status-message" id="statusMessage"></div>
<style>
    :root {
        --neon-pink: #ff71ce;
        --neon-blue: #01cdfe;
        --neon-purple: #b967ff;
        --neon-green: #05ffa1;
        --dark-bg: #1a1a2e;
        --grid-color: rgba(255, 113, 206, 0.1);
        --modal-bg: rgba(26, 26, 46, 0.95);
        --error-red: #ff4444;
        --success-green: #00C851;
        --warning-yellow: #ffbb33;
        --retrowave-gradient: linear-gradient(
            45deg,
            var(--neon-pink),
            var(--neon-purple),
            var(--neon-blue)
        );
        --telegram-blue: #0088cc;
    }

    * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        touch-action: manipulation;
        margin: 0;
        padding: 0;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto;
        margin: 0;
        padding: 16px;
        background-color: var(--dark-bg);
        color: white;
        min-height: 100vh;
        overscroll-behavior: none;
        position: relative;
    }

    .app-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 0;
        position: relative;
        z-index: 1;
    }

    .canvas-wrapper {
        position: relative;
        width: 100%;
        padding-top: 75%;
        margin-bottom: 8px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 12px;
        border: 2px solid var(--neon-blue);
        box-shadow: 0 0 15px var(--neon-blue);
        overflow: hidden;
    }

    .canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
        background: #000;
    }

    #memeCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
        display: block;
    }

    .stogie-selector {
        width: 100%;
        margin: 8px 0;
        display: flex;
        gap: 10px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid var(--neon-pink);
        border-radius: 12px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        box-shadow: 0 0 10px var(--neon-pink);
        backdrop-filter: blur(5px);
        scrollbar-width: none;
        -ms-overflow-style: none;
    }

    .stogie-selector::-webkit-scrollbar {
        display: none;
    }

    .stogie-option {
        flex: 0 0 80px;
        height: 50px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid var(--neon-purple);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        padding: 5px;
        position: relative;
    }

    .stogie-option:active {
        transform: scale(0.95);
        background: rgba(255, 255, 255, 0.2);
    }

    .stogie-option img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        pointer-events: none;
    }

    .control-panel {
        background: rgba(0, 0, 0, 0.5);
        padding: 20px;
        border-radius: 12px;
        margin: 8px 0;
        border: 1px solid var(--neon-green);
        box-shadow: 0 0 10px var(--neon-green);
        backdrop-filter: blur(5px);
    }

    .button {
        background: var(--retrowave-gradient);
        color: white;
        border: none;
        padding: 16px 20px;
        border-radius: 8px;
        font-size: 16px;
        width: 100%;
        margin-bottom: 12px;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        text-transform: uppercase;
        font-weight: bold;
        letter-spacing: 1px;
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        position: relative;
        overflow: hidden;
    }

    .button:active {
        transform: scale(0.98);
    }

    .button::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(rgba(255,255,255,0.1), transparent);
        pointer-events: none;
    }

    .delete-button {
        background: linear-gradient(45deg, #ff0844, #ffb199);
    }

    .delete-button.disabled {
        opacity: 0.5;
        pointer-events: none;
    }

    .slider-container {
        margin: 16px 0;
    }

    .slider-container label {
        display: block;
        margin-bottom: 8px;
        color: var(--neon-pink);
        text-transform: uppercase;
        font-size: 14px;
        letter-spacing: 1px;
    }

    input[type="range"] {
        width: 100%;
        height: 36px;
        -webkit-appearance: none;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        outline: none;
        border: 1px solid var(--neon-blue);
        margin: 0;
        padding: 0;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 24px;
        height: 24px;
        background: var(--neon-purple);
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 0 10px var(--neon-purple);
        border: none;
        margin-top: -8px;
    }

    input[type="range"]::-webkit-slider-runnable-track {
        height: 8px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        border: none;
    }

    #fileInput {
        display: none;
    }

    .preview-modal, .instruction-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--modal-bg);
        z-index: 1000;
        padding: 20px;
        backdrop-filter: blur(10px);
        touch-action: none;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }

    .instruction-overlay {
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .preview-content, .instruction-content {
        max-width: 800px;
        margin: 0 auto;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 12px;
        padding: 20px;
        border: 1px solid var(--neon-blue);
        box-shadow: 0 0 20px var(--neon-blue);
        position: relative;
    }

    .preview-content h2 {
        margin: 0 0 20px 0;
        text-align: center;
        color: var(--neon-pink);
        text-transform: uppercase;
        letter-spacing: 2px;
        font-size: 20px;
    }

    .preview-image-container {
        width: 100%;
        margin-bottom: 20px;
        border-radius: 8px;
        overflow: hidden;
        background: #000;
    }

    .preview-image {
        width: 100%;
        display: block;
        border-radius: 8px;
    }

    .share-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
        gap: 10px;
        margin-top: 20px;
    }

    .share-button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--neon-purple);
        color: white;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .share-button:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .share-button:active {
        transform: translateY(0);
    }

    .share-button.download {
        border-color: var(--neon-green);
    }

    .custom-arrow {
        position: absolute;
        top: 15px;
        right: 45px;
        animation: neonPulse 1.5s infinite;
    }

    .custom-arrow svg {
        width: 60px;
        height: 60px;
    }

    .custom-arrow path {
        fill: none;
        stroke: var(--neon-pink);
        stroke-width: 3;
        filter: drop-shadow(0 0 8px var(--neon-pink));
        transform-origin: center;
        transform: rotate(45deg);
    }

    .instruction-text {
        margin-top: 100px;
        font-size: 18px;
        line-height: 1.5;
        max-width: 300px;
        background: rgba(0, 0, 0, 0.5);
        padding: 20px;
        border-radius: 12px;
        border: 2px solid var(--neon-blue);
        box-shadow: 0 0 15px var(--neon-blue);
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        margin-left: auto;
        margin-right: auto;
    }

    .got-it-btn {
        margin-top: 20px;
        padding: 16px 24px;
        background: var(--retrowave-gradient);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        width: 100%;
    }

    .skip-btn {
        margin-top: 10px;
        padding: 12px 20px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 2px solid var(--neon-blue);
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        width: 100%;
    }

    .skip-btn:active {
        transform: scale(0.95);
        background: rgba(255, 255, 255, 0.2);
    }

    .got-it-btn:active {
        transform: scale(0.95);
    }

    .step-2 {
        display: none;
    }

    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        backdrop-filter: blur(5px);
        flex-direction: column;
        gap: 20px;
    }

    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid var(--neon-blue);
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    .loading-text {
        color: white;
        font-size: 16px;
        text-align: center;
        max-width: 80%;
        animation: pulse 1.5s infinite;
    }

    .status-message {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 24px;
        border-radius: 8px;
        color: white;
        font-weight: 500;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 2001;
        pointer-events: none;
        max-width: 90%;
        text-align: center;
        backdrop-filter: blur(5px);
    }

    .status-message.show {
        opacity: 1;
    }

    .status-message.success {
        background-color: var(--success-green);
        box-shadow: 0 0 15px rgba(0, 200, 81, 0.5);
    }

    .status-message.error {
        background-color: var(--error-red);
        box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
    }

    .status-message.warning {
        background-color: var(--warning-yellow);
        box-shadow: 0 0 15px rgba(255, 187, 51, 0.5);
    }

    .fade-in {
        display: block;
        opacity: 1;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    @keyframes pulse {
        0% { opacity: 0.6; }
        50% { opacity: 1; }
        100% { opacity: 0.6; }
    }

    @keyframes neonPulse {
        0%, 100% {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        50% {
            opacity: 0.7;
            transform: translateY(-10px) scale(1.05);
        }
    }

    @media (max-width: 480px) {
        body {
            padding: 8px;
        }

        .preview-content {
            padding: 15px;
        }

        .preview-content h2 {
            font-size: 18px;
            margin-bottom: 15px;
        }

        .share-button {
            padding: 10px;
            font-size: 12px;
        }

        .status-message {
            font-size: 14px;
            padding: 10px 20px;
        }

        .instruction-text {
            margin-top: 80px;
            font-size: 16px;
            padding: 15px;
        }

        .got-it-btn {
            padding: 12px 20px;
            font-size: 14px;
        }

        .custom-arrow {
            right: 35px;
        }

        .custom-arrow svg {
            width: 50px;
            height: 50px;
        }
    }
</style>
<script>
// Security and Platform Utils
const platformUtils = {
    isTelegram: Boolean(window.Telegram?.WebApp),
    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
    
    init: function() {
        console.log('Platform detection:', {
            isTelegram: this.isTelegram,
            isMobile: this.isMobile,
            userAgent: navigator.userAgent,
            isTelegramWebView: this.isInTelegramWebView()
        });

        document.body.setAttribute('data-platform', this.isMobile ? 'mobile' : 'pc');
        
        // Show instructions only if on mobile and in Telegram WebView
        if (this.isMobile && this.isInTelegramWebView()) {
            // Check if user has already completed the instruction
            const hasCompletedInstruction = localStorage.getItem('instructionComplete');
            if (!hasCompletedInstruction) {
                this.showMobileRedirectPrompt();
            }
        }
    },

    isInTelegramWebView: function() {
        return Boolean(window.Telegram?.WebApp) || 
               window.navigator.userAgent.includes('Telegram') ||
               window.location.search.includes('tgWebApp');
    },

    showMobileRedirectPrompt: function() {
        const overlay = document.getElementById('instructionOverlay');
        overlay.classList.add('fade-in');
    },

    setupEnvironment: function() {
        if (this.isTelegram) {
            console.log('Setting up Telegram features');
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
        }
    }
};

// Status handling
const statusHandler = {
    show: function(message, type = 'success', duration = 3000) {
        const statusEl = document.getElementById('statusMessage');
        statusEl.textContent = message;
        statusEl.className = `status-message ${type} show`;
        
        setTimeout(() => {
            statusEl.className = 'status-message';
        }, duration);
    },

    showProgress: function(message) {
        const statusEl = document.getElementById('statusMessage');
        statusEl.textContent = message;
        statusEl.className = 'status-message progress show';
    }
};

// Loading overlay handler
const loadingHandler = {
    show: function(message = 'Processing...') {
        const overlay = document.getElementById('loadingOverlay');
        const text = overlay.querySelector('.loading-text');
        text.textContent = message;
        overlay.style.display = 'flex';
    },
    
    hide: function() {
        document.getElementById('loadingOverlay').style.display = 'none';
    },

    updateMessage: function(message) {
        const text = document.getElementById('loadingOverlay').querySelector('.loading-text');
        text.textContent = message;
    }
};

// Error handler
const errorHandler = {
    handle: function(error, context = '') {
        console.error(`Error in ${context}:`, error);
        
        const errorMessage = error.message || 'An error occurred. Please try again.';
        statusHandler.show(errorMessage, 'error');
        
        loadingHandler.hide();
    }
};

// Core variables
const canvas = document.getElementById('memeCanvas');
const ctx = canvas.getContext('2d');
const baseImage = new Image();
let overlays = [];
let activeOverlay = null;
let isDragging = false;
let startX, startY;
let canvasScale = 1;

// Canvas initialization and utilities
const canvasUtils = {
    init: function() {
        try {
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvasScale = dpr;
            
            this.draw();
        } catch (error) {
            errorHandler.handle(error, 'canvas initialization');
        }
    },

    draw: function() {
        try {
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = canvas.width / dpr;
            const displayHeight = canvas.height / dpr;

            // Clear and set background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw base image if exists
            if (baseImage.src) {
                this.drawBaseImage(displayWidth, displayHeight);
            }

            // Draw overlays
            overlays.forEach(overlay => this.drawOverlay(overlay));
            
        } catch (error) {
            errorHandler.handle(error, 'canvas drawing');
        }
    },

    drawBaseImage: function(displayWidth, displayHeight) {
        const imgRatio = baseImage.width / baseImage.height;
        const canvasRatio = displayWidth / displayHeight;
        let drawWidth, drawHeight, x, y;

        if (imgRatio > canvasRatio) {
            drawWidth = displayWidth;
            drawHeight = displayWidth / imgRatio;
            x = 0;
            y = (displayHeight - drawHeight) / 2;
        } else {
            drawHeight = displayHeight;
            drawWidth = displayHeight * imgRatio;
            x = (displayWidth - drawWidth) / 2;
            y = 0;
        }

        ctx.drawImage(baseImage, x, y, drawWidth, drawHeight);
    },

    drawOverlay: function(overlay) {
        ctx.save();
        const dpr = window.devicePixelRatio || 1;
        const x = overlay.x / dpr;
        const y = overlay.y / dpr;

        ctx.translate(x, y);
        ctx.rotate(overlay.rotation * Math.PI / 180);
        ctx.scale(overlay.scale, overlay.scale);

        ctx.drawImage(
            overlay.image,
            -overlay.image.width / 2,
            -overlay.image.height / 2
        );

        if (overlay === activeOverlay) {
            this.drawOverlayBorder(overlay);
        }

        ctx.restore();
    },

    drawOverlayBorder: function(overlay) {
        ctx.strokeStyle = 'var(--neon-pink)';
        ctx.lineWidth = 2 / overlay.scale;
        ctx.strokeRect(
            -overlay.image.width / 2,
            -overlay.image.height / 2,
            overlay.image.width,
            overlay.image.height
        );
    }
};
// Image processing utilities
const imageUtils = {
    processImage: async function(file) {
        try {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = () => {
                    baseImage.src = reader.result;
                    baseImage.onload = () => {
                        resolve();
                    };
                    baseImage.onerror = () => reject(new Error('Failed to load image'));
                };
                
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });
        } catch (error) {
            errorHandler.handle(error, 'image processing');
            throw error;
        }
    },

    compressImage: async function(file, maxSize = 5 * 1024 * 1024) {
        if (file.size <= maxSize) {
            return file;
        }

        try {
            const img = new Image();
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });

            let quality = 0.8;
            let outputBlob;
            
            do {
                const scale = Math.min(1, Math.sqrt(maxSize / file.size));
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
                
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                const dataUrl = canvas.toDataURL('image/jpeg', quality);
                const binaryString = atob(dataUrl.split(',')[1]);
                const bytes = new Uint8Array(binaryString.length);
                
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                outputBlob = new Blob([bytes], { type: 'image/jpeg' });
                quality -= 0.1;
            } while (outputBlob.size > maxSize && quality > 0.3);

            URL.revokeObjectURL(img.src);
            
            return new File([outputBlob], 'compressed-meme.jpg', { type: 'image/jpeg' });
        } catch (error) {
            errorHandler.handle(error, 'image compression');
            return file;
        }
    }
};

// Sharing utilities
const sharingUtils = {
    async generateHighResCanvas() {
        const exportCanvas = document.createElement('canvas');
        const exportCtx = exportCanvas.getContext('2d');
        const scale = 2;

        exportCanvas.width = canvas.width * scale;
        exportCanvas.height = canvas.height * scale;

        try {
            exportCtx.scale(scale * canvasScale, scale * canvasScale);
            
            if (baseImage.src) {
                const dimensions = this.calculateImageDimensions();
                exportCtx.drawImage(baseImage, dimensions.x, dimensions.y, 
                                 dimensions.width, dimensions.height);
            }

            overlays.forEach(overlay => {
                this.drawOverlayToCanvas(exportCtx, overlay, canvasScale);
            });

            return exportCanvas;
        } catch (error) {
            errorHandler.handle(error, 'generating high-res canvas');
            throw new Error('Failed to generate image');
        }
    },

    calculateImageDimensions() {
        const imgRatio = baseImage.width / baseImage.height;
        const canvasRatio = canvas.width / canvas.height;
        let width, height, x, y;

        if (imgRatio > canvasRatio) {
            width = canvas.width / canvasScale;
            height = (canvas.width / canvasScale) / imgRatio;
            x = 0;
            y = (canvas.height / canvasScale - height) / 2;
        } else {
            height = canvas.height / canvasScale;
            width = (canvas.height / canvasScale) * imgRatio;
            x = (canvas.width / canvasScale - width) / 2;
            y = 0;
        }

        return { width, height, x, y };
    },

    drawOverlayToCanvas(ctx, overlay, scale) {
        ctx.save();
        const x = overlay.x / scale;
        const y = overlay.y / scale;
        
        ctx.translate(x, y);
        ctx.rotate(overlay.rotation * Math.PI / 180);
        ctx.scale(overlay.scale, overlay.scale);
        
        ctx.drawImage(
            overlay.image,
            -overlay.image.width / 2,
            -overlay.image.height / 2
        );
        
        ctx.restore();
    },

    async convertCanvasToFile(canvas) {
        try {
            return new Promise((resolve, reject) => {
                canvas.toBlob(blob => {
                    if (blob) {
                        const file = new File([blob], 'meme.png', { 
                            type: 'image/png',
                            lastModified: Date.now()
                        });
                        resolve(file);
                    } else {
                        reject(new Error('Failed to create image file'));
                    }
                }, 'image/png', 1.0);
            });
        } catch (error) {
            errorHandler.handle(error, 'converting canvas to file');
            throw error;
        }
    }
};

// Event Handlers and Functions
async function downloadImage() {
    loadingHandler.show('Preparing download...');
    
    try {
        const exportCanvas = await sharingUtils.generateHighResCanvas();
        const imageFile = await sharingUtils.convertCanvasToFile(exportCanvas);
        
        const url = URL.createObjectURL(imageFile);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'meme.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        statusHandler.show('Image downloaded successfully!', 'success');
    } catch (error) {
        errorHandler.handle(error, 'downloading image');
    } finally {
        loadingHandler.hide();
    }
}

async function copyToClipboard() {
    loadingHandler.show('Copying to clipboard...');
    
    try {
        const exportCanvas = await sharingUtils.generateHighResCanvas();
        const blob = await new Promise(resolve => exportCanvas.toBlob(resolve));
        
        await navigator.clipboard.write([
            new ClipboardItem({
                [blob.type]: blob
            })
        ]);
        
        statusHandler.show('Copied to clipboard!', 'success');
    } catch (error) {
        errorHandler.handle(error, 'copying to clipboard');
    } finally {
        loadingHandler.hide();
    }
}

async function shareToSocial() {
    loadingHandler.show('Preparing to share...');
    
    try {
        const exportCanvas = await sharingUtils.generateHighResCanvas();
        const imageFile = await sharingUtils.convertCanvasToFile(exportCanvas);
        
        if (navigator.share) {
            await navigator.share({
                files: [imageFile],
                title: 'Check out my meme!',
                text: 'Created with Meme Maker'
            });
            statusHandler.show('Shared successfully!', 'success');
        } else {
            downloadImage();
        }
    } catch (error) {
        if (error.name !== 'AbortError') {
            errorHandler.handle(error, 'sharing to social');
        }
    } finally {
        loadingHandler.hide();
    }
}
// Instruction overlay functions
function showInstructions() {
    const overlay = document.getElementById('instructionOverlay');
    overlay.classList.add('fade-in');
}

function showStep2() {
    const step1 = document.querySelector('.step-1');
    const step2 = document.querySelector('.step-2');
    
    step1.style.display = 'none';
    step2.style.display = 'block';
}

function closeInstructions() {
    const overlay = document.getElementById('instructionOverlay');
    overlay.classList.remove('fade-in');
    
    setTimeout(() => {
        overlay.style.display = 'none';
    }, 300);
}

function skipInstructions() {
    localStorage.setItem('instructionComplete', 'true');
    closeInstructions();
}

// Event Listeners
document.getElementById('fileInput').addEventListener('change', async function(e) {
    const file = e.target.files[0];
    if (file) {
        loadingHandler.show('Processing image...');
        try {
            await imageUtils.processImage(file);
            canvasUtils.draw();
            statusHandler.show('Image loaded successfully!', 'success');
        } catch (error) {
            errorHandler.handle(error, 'file input');
        } finally {
            loadingHandler.hide();
        }
    }
});

// Stogie selector handlers
document.querySelectorAll('.stogie-option').forEach(option => {
    option.addEventListener('click', () => {
        const img = option.querySelector('img');
        if (img) {
            const overlayImg = new Image();
            overlayImg.crossOrigin = "Anonymous";
            overlayImg.src = img.dataset.src;
            
            overlayImg.onload = () => {
                const dpr = window.devicePixelRatio || 1;
                const overlay = {
                    image: overlayImg,
                    x: (canvas.width / dpr) / 2,
                    y: (canvas.height / dpr) / 2,
                    rotation: 0,
                    scale: 0.2,
                    initialWidth: overlayImg.width,
                    initialHeight: overlayImg.height,
                    type: option.dataset.type
                };
                
                overlays.push(overlay);
                activeOverlay = overlay;
                document.getElementById('rotationSlider').value = 180;
                document.getElementById('scaleSlider').value = 37.5;
                updateDeleteButtonState();
                canvasUtils.draw();
            };

            overlayImg.onerror = () => {
                errorHandler.handle(new Error('Failed to load overlay image'), 'loading overlay');
            };
        }
    });
});

// Touch event handlers
canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd);

function handleTouchStart(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const pos = getTouchPos(touch);
    
    const clickedOverlay = findClickedOverlay(pos.x, pos.y);
    if (activeOverlay !== clickedOverlay) {
        activeOverlay = clickedOverlay;
        updateDeleteButtonState();
        canvasUtils.draw();
    }
    
    if (clickedOverlay) {
        isDragging = true;
        startX = pos.x - clickedOverlay.x;
        startY = pos.y - clickedOverlay.y;
        
        document.getElementById('rotationSlider').value = clickedOverlay.rotation + 180;
        document.getElementById('scaleSlider').value = clickedOverlay.scale * 100;
    }
}

function handleTouchMove(e) {
    e.preventDefault();
    if (!isDragging || !activeOverlay) return;

    const touch = e.touches[0];
    const pos = getTouchPos(touch);
    
    activeOverlay.x = pos.x - startX;
    activeOverlay.y = pos.y - startY;
    
    canvasUtils.draw();
}

function handleTouchEnd() {
    isDragging = false;
}

// Mouse event handlers
canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);

function handleMouseDown(e) {
    const pos = getMousePos(e);
    const clickedOverlay = findClickedOverlay(pos.x, pos.y);
    
    if (activeOverlay !== clickedOverlay) {
        activeOverlay = clickedOverlay;
        updateDeleteButtonState();
        canvasUtils.draw();
    }
    
    if (clickedOverlay) {
        isDragging = true;
        startX = pos.x - clickedOverlay.x;
        startY = pos.y - clickedOverlay.y;
        
        document.getElementById('rotationSlider').value = clickedOverlay.rotation + 180;
        document.getElementById('scaleSlider').value = clickedOverlay.scale * 100;
    }
}

function handleMouseMove(e) {
    if (!isDragging || !activeOverlay) return;

    const pos = getMousePos(e);
    activeOverlay.x = pos.x - startX;
    activeOverlay.y = pos.y - startY;
    
    canvasUtils.draw();
}

function handleMouseUp() {
    isDragging = false;
}

// Utility functions for position calculations
function getTouchPos(touch) {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    return {
        x: (touch.clientX - rect.left) * dpr,
        y: (touch.clientY - rect.top) * dpr
    };
}

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    return {
        x: (e.clientX - rect.left) * dpr,
        y: (e.clientY - rect.top) * dpr
    };
}

function findClickedOverlay(x, y) {
    const dpr = window.devicePixelRatio || 1;
    return overlays.slice().reverse().find(overlay => {
        const dx = (x - overlay.x);
        const dy = (y - overlay.y);
        const distance = Math.sqrt(dx * dx + dy * dy);
        const hitboxSize = overlay.image.width * overlay.scale * dpr / 2;
        return distance < hitboxSize;
    }) || null;
}

// Slider handlers
document.getElementById('rotationSlider').addEventListener('input', e => {
    if (activeOverlay) {
        const sliderValue = parseInt(e.target.value);
        activeOverlay.rotation = sliderValue - 180;
        canvasUtils.draw();
    }
});

document.getElementById('scaleSlider').addEventListener('input', e => {
    if (activeOverlay) {
        const scaleValue = parseInt(e.target.value);
        activeOverlay.scale = scaleValue / 100;
        canvasUtils.draw();
    }
});

// Delete button handler
document.getElementById('deleteButton').addEventListener('click', () => {
    if (activeOverlay) {
        overlays = overlays.filter(overlay => overlay !== activeOverlay);
        activeOverlay = null;
        updateDeleteButtonState();
        canvasUtils.draw();
        
        document.getElementById('rotationSlider').value = 180;
        document.getElementById('scaleSlider').value = 37.5;
        
        statusHandler.show('Item deleted', 'success');
    }
});

// Preview button handler
document.getElementById('previewButton').addEventListener('click', async () => {
    loadingHandler.show('Generating preview...');
    
    try {
        const exportCanvas = await sharingUtils.generateHighResCanvas();
        const previewImage = document.getElementById('previewImage');
        previewImage.src = exportCanvas.toDataURL('image/png');
        document.getElementById('previewModal').style.display = 'flex';
    } catch (error) {
        errorHandler.handle(error, 'generating preview');
    } finally {
        loadingHandler.hide();
    }
});

function updateDeleteButtonState() {
    const deleteButton = document.getElementById('deleteButton');
    deleteButton.classList.toggle('disabled', !activeOverlay);
}

// Window event handlers
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        canvasUtils.init();
    }, 250);
});

// Initialize everything when the window loads
window.addEventListener('load', function() {
    platformUtils.init();
    canvasUtils.init();
});
</script>
</body>
</html>

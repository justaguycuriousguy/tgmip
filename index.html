<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vaporwave Meme Maker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --neon-pink: #ff71ce;
            --neon-blue: #01cdfe;
            --neon-purple: #b967ff;
            --neon-green: #05ffa1;
            --dark-bg: #1a1a2e;
            --grid-color: rgba(255, 113, 206, 0.1);
            --modal-bg: rgba(26, 26, 46, 0.95);
            --retrowave-gradient: linear-gradient(
                45deg,
                var(--neon-pink),
                var(--neon-purple),
                var(--neon-blue)
            );
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto; margin: 0; padding: 16px; background-color: var(--dark-bg); background-image: linear-gradient(var(--grid-color) 2px, transparent 2px), linear-gradient(90deg, var(--grid-color) 2px, transparent 2px); background-size: 40px 40px; color: white; min-height: 100vh; touch-action: manipulation; }
        .canvas-container { position: relative; width: 100%; height: calc(100vw * 0.75); max-height: 400px; background: rgba(0, 0, 0, 0.5); margin-bottom: 8px; border-radius: 12px; border: 2px solid var(--neon-blue); box-shadow: 0 0 15px var(--neon-blue); overflow: hidden; user-select: none; -webkit-user-select: none; backdrop-filter: blur(5px); }
        #baseImage { width: 100%; height: 100%; object-fit: contain; display: block; pointer-events: none; position: absolute; top: 0; left: 0; }
        .overlay-image { position: absolute; width: 150px; height: auto; cursor: move; left: 50%; top: 50%; transform: translate(-50%, -50%) rotate(0deg) scale(1); z-index: 1000; user-select: none; -webkit-user-select: none; pointer-events: all; transform-origin: center; transition: outline-color 0.3s ease; }
        .overlay-image.selected { outline: 2px solid var(--neon-pink); outline-offset: 2px; box-shadow: 0 0 15px var(--neon-pink); }
        .upload-area { text-align: center; padding: 40px; color: var(--neon-blue); font-size: 18px; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--neon-blue); position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
        .stogie-selector { display: flex; gap: 10px; margin-bottom: 16px; padding: 15px; background: rgba(0, 0, 0, 0.5); border: 1px solid var(--neon-pink); border-radius: 12px; overflow-x: auto; -webkit-overflow-scrolling: touch; box-shadow: 0 0 10px var(--neon-pink); backdrop-filter: blur(5px); }
        .stogie-option { flex: 0 0 80px; height: 50px; background: rgba(255, 255, 255, 0.1); border: 2px solid var(--neon-purple); border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; overflow: hidden; padding: 5px; transition: all 0.3s ease; }
        .stogie-option img { max-width: 100%; max-height: 100%; object-fit: contain; pointer-events: none; }
        .control-panel { background: rgba(0, 0, 0, 0.5); padding: 20px; border-radius: 12px; margin-bottom: 16px; border: 1px solid var(--neon-green); box-shadow: 0 0 10px var(--neon-green); backdrop-filter: blur(5px); }
        .button { background: var(--retrowave-gradient); color: white; border: none; padding: 12px 20px; border-radius: 8px; font-size: 16px; width: 100%; margin-bottom: 12px; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; font-weight: bold; letter-spacing: 1px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
        .button:active { transform: scale(0.98); box-shadow: 0 0 20px var(--neon-purple); }
        .delete-button.disabled { background: #333; cursor: not-allowed; opacity: 0.5; }
        .slider-container { margin: 12px 0; }
        .slider-container label { display: block; margin-bottom: 8px; color: var(--neon-pink); text-transform: uppercase; font-size: 14px; letter-spacing: 1px; }
        input[type="range"] { width: 100%; height: 36px; -webkit-appearance: none; background: rgba(255, 255, 255, 0.1); border-radius: 8px; outline: none; border: 1px solid var(--neon-blue); }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 24px; height: 24px; background: var(--neon-purple); border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px var(--neon-purple); border: none; margin-top: -8px; }
        input[type="range"]::-webkit-slider-runnable-track { height: 8px; background: rgba(255, 255, 255, 0.2); border-radius: 4px; border: none; }
        .preview-modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--modal-bg); z-index: 1000; padding: 20px; backdrop-filter: blur(10px); align-items: center; justify-content: center; }
        .preview-content { max-width: 600px; margin: 0 auto; background: rgba(0, 0, 0, 0.7); border-radius: 12px; padding: 20px; border: 1px solid var(--neon-blue); box-shadow: 0 0 20px var(--neon-blue); text-align: center; }
        .preview-image { width: 100%; border-radius: 8px; margin-bottom: 20px; }
        .share-button { background: rgba(255, 255, 255, 0.1); border: 1px solid var(--neon-purple); color: white; padding: 12px; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; gap: 8px; margin: 10px 0; }
        .share-button:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-2px); }
        @media (max-width: 480px) { body { padding: 8px; } .canvas-container { height: calc(100vw * 0.8); } .button { padding: 15px 20px; font-size: 14px; } .overlay-image { width: 120px; } .upload-area { font-size: 16px; padding: 20px; } }
    </style>
</head>
<body>
    <!-- Canvas Container -->
    <div class="canvas-container" id="canvasContainer">
        <div class="upload-area" id="uploadArea">
            Click "Choose Image" to start
        </div>
        <img id="baseImage" style="display: none;">
    </div>

    <!-- Stogie Selector -->
    <div class="stogie-selector" id="stogieSelector">
        <div class="stogie-option">
            <img src="images/stogie.png" alt="Stogie 1" data-type="overlay">
        </div>
        <div class="stogie-option">
            <img src="images/stogie2.png" alt="Stogie 2" data-type="overlay">
        </div>
        <div class="stogie-option">
            <img src="images/stogie3.png" alt="Stogie 3" data-type="overlay">
        </div>
        <div class="stogie-option">
            <img src="images/glasses.png" alt="Glasses" data-type="overlay">
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <input type="file" id="fileInput" accept="image/*" style="display: none;">
        <button class="button" onclick="document.getElementById('fileInput').click()">
            <i class="fas fa-image"></i> Choose Image
        </button>

        <div class="slider-container">
            <label>Rotation</label>
            <input type="range" id="rotationSlider" min="0" max="360" value="0">
        </div>

        <div class="slider-container">
            <label>Size</label>
            <input type="range" id="scaleSlider" min="50" max="200" value="100">
        </div>

        <button class="button delete-button disabled" id="deleteButton">
            <i class="fas fa-trash"></i> Delete Selected
        </button>

        <button class="button" id="previewButton">
            <i class="fas fa-eye"></i> Preview & Share
        </button>
    </div>

    <!-- Preview Modal -->
    <div class="preview-modal" id="previewModal">
        <div class="preview-content">
            <button class="modal-close" onclick="closePreview()">Ã—</button>
            <h2>Preview & Share</h2>
            <img id="previewImage" class="preview-image" alt="Preview">
            
            <button class="share-button telegram" onclick="shareToTelegram()">
                <i class="fab fa-telegram"></i> Telegram
            </button>
            <button class="share-button twitter" onclick="shareToTwitter()">
                <i class="fab fa-twitter"></i> Twitter
            </button>
            <button class="share-button" onclick="downloadImage()">
                <i class="fas fa-download"></i> Download
            </button>
            <button class="share-button" onclick="shareNative()">
                <i class="fas fa-share-alt"></i> Native Share
            </button>
        </div>
    </div>
<script>
    const container = document.getElementById('canvasContainer');
    const rotationSlider = document.getElementById('rotationSlider');
    const scaleSlider = document.getElementById('scaleSlider');
    const fileInput = document.getElementById('fileInput');
    const baseImage = document.getElementById('baseImage');
    const uploadArea = document.getElementById('uploadArea');
    const deleteButton = document.getElementById('deleteButton');
    const previewModal = document.getElementById('previewModal');
    const previewImage = document.getElementById('previewImage');

    let activeOverlay = null;
    let overlays = [];
    let isDragging = false;
    let initialX = 0;
    let initialY = 0;

    function createOverlay(source) {
        const overlay = document.createElement('img');
        overlay.src = source;
        overlay.className = 'overlay-image';
        overlay.dataset.x = 0;
        overlay.dataset.y = 0;
        overlay.dataset.rotation = 0;
        overlay.dataset.scale = 1;

        container.appendChild(overlay);
        overlays.push(overlay);

        overlay.addEventListener('mousedown', handleStart);
        overlay.addEventListener('touchstart', handleStart, { passive: false });

        selectOverlay(overlay);
        return overlay;
    }

    function selectOverlay(overlay) {
        overlays.forEach(o => o.classList.remove('selected'));
        overlay.classList.add('selected');
        activeOverlay = overlay;
        deleteButton.classList.remove('disabled');
        rotationSlider.value = overlay.dataset.rotation || 0;
        scaleSlider.value = (overlay.dataset.scale || 1) * 100;
    }
    // Event listener for the Preview button to open the preview modal
    document.getElementById('previewButton').addEventListener('click', async () => {
        try {
            // Generate the final image canvas for preview
            const canvas = await renderFinalImage(2);
            
            // Convert the canvas to a data URL and set it as the source of the preview image
            previewImage.src = canvas.toDataURL('image/png');
            
            // Display the preview modal
            previewModal.style.display = 'flex';
        } catch (error) {
            console.error("Error generating preview:", error);
        }
    });

    function handleStart(e) {
        if (e.target.classList.contains('overlay-image')) {
            selectOverlay(e.target);
            dragStart(e);
        }
    }

    function dragStart(e) {
        if (!activeOverlay) return;

        isDragging = true;

        if (e.type === "touchstart") {
            const touch = e.touches[0];
            initialX = touch.clientX - (parseFloat(activeOverlay.dataset.x) || 0);
            initialY = touch.clientY - (parseFloat(activeOverlay.dataset.y) || 0);
        } else {
            initialX = e.clientX - (parseFloat(activeOverlay.dataset.x) || 0);
            initialY = e.clientY - (parseFloat(activeOverlay.dataset.y) || 0);
        }

        e.preventDefault();
    }

    function drag(e) {
        if (!isDragging || !activeOverlay) return;

        e.preventDefault();

        let clientX, clientY;

        if (e.type === "touchmove") {
            const touch = e.touches[0];
            clientX = touch.clientX;
            clientY = touch.clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        const rect = container.getBoundingClientRect();
        const x = clientX - initialX - rect.left;
        const y = clientY - initialY - rect.top;

        activeOverlay.dataset.x = x;
        activeOverlay.dataset.y = y;
        updateOverlayPosition(activeOverlay);
    }

    function dragEnd() {
        isDragging = false;
    }

    function updateOverlayPosition(overlay) {
        if (!overlay) return;

        const rotation = overlay.dataset.rotation || 0;
        const scale = overlay.dataset.scale || 1;
        const x = overlay.dataset.x || 0;
        const y = overlay.dataset.y || 0;

        overlay.style.transform = 
            `translate(${x}px, ${y}px) 
             rotate(${rotation}deg) 
             scale(${scale})`;
    }

    document.addEventListener('mousemove', drag);
    document.addEventListener('touchmove', drag, { passive: false });
    document.addEventListener('mouseup', dragEnd);
    document.addEventListener('touchend', dragEnd);

    fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                baseImage.src = event.target.result;
                baseImage.style.display = 'block';
                uploadArea.style.display = 'none';
            };
            reader.readAsDataURL(file);
        }
    });

    document.querySelectorAll('.stogie-option').forEach(option => {
        option.addEventListener('click', () => {
            const img = option.querySelector('img');
            if (img) {
                createOverlay(img.src);
            }
        });
    });

    deleteButton.addEventListener('click', () => {
        if (activeOverlay) {
            container.removeChild(activeOverlay);
            overlays = overlays.filter(o => o !== activeOverlay);
            activeOverlay = null;
            deleteButton.classList.add('disabled');
        }
    });

    rotationSlider.addEventListener('input', () => {
        if (activeOverlay) {
            activeOverlay.dataset.rotation = rotationSlider.value;
            updateOverlayPosition(activeOverlay);
        }
    });

    scaleSlider.addEventListener('input', () => {
        if (activeOverlay) {
            activeOverlay.dataset.scale = scaleSlider.value / 100;
            updateOverlayPosition(activeOverlay);
        }
    });
    async function renderFinalImage(quality = 2) {
        // Create a new canvas for rendering the final image
        const finalCanvas = document.createElement('canvas');
        const ctx = finalCanvas.getContext('2d');
        
        // Get the dimensions of the canvas container and scale it based on the quality setting
        const containerRect = container.getBoundingClientRect();
        const scaleFactor = quality;
        finalCanvas.width = containerRect.width * scaleFactor;
        finalCanvas.height = containerRect.height * scaleFactor;
    
        // Enable high-quality image smoothing
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
    
        // Draw the base image with the appropriate aspect ratio
        if (baseImage.src) {
            await new Promise((resolve) => {
                if (baseImage.complete) resolve();
                else baseImage.onload = resolve;
            });
    
            // Calculate dimensions to keep the aspect ratio correct
            const imgRatio = baseImage.naturalWidth / baseImage.naturalHeight;
            const containerRatio = containerRect.width / containerRect.height;
            let drawWidth, drawHeight, offsetX, offsetY;
    
            if (containerRatio > imgRatio) {
                drawHeight = finalCanvas.height;
                drawWidth = drawHeight * imgRatio;
                offsetX = (finalCanvas.width - drawWidth) / 2;
                offsetY = 0;
            } else {
                drawWidth = finalCanvas.width;
                drawHeight = drawWidth / imgRatio;
                offsetX = 0;
                offsetY = (finalCanvas.height - drawHeight) / 2;
            }
    
            ctx.drawImage(baseImage, offsetX, offsetY, drawWidth, drawHeight);
        }
    
        // Draw each overlay at the correct position, scale, and rotation
        for (const overlay of overlays) {
            await new Promise((resolve) => {
                if (overlay.complete) resolve();
                else overlay.onload = resolve;
            });
    
            // Retrieve the overlay's attributes (position, rotation, and scale)
            const overlayScale = parseFloat(overlay.dataset.scale) || 1;
            const overlayRotation = parseFloat(overlay.dataset.rotation) || 0;
            const overlayX = parseFloat(overlay.dataset.x) || 0;
            const overlayY = parseFloat(overlay.dataset.y) || 0;
    
            // Adjust the overlay's coordinates for the scaling factor
            const x = (overlayX + overlay.width / 2) * scaleFactor;
            const y = (overlayY + overlay.height / 2) * scaleFactor;
    
            // Apply transformations: translation, rotation, and scaling
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate((overlayRotation * Math.PI) / 180);
            ctx.scale(overlayScale * scaleFactor, overlayScale * scaleFactor);
    
            // Draw the overlay at the adjusted position
            ctx.drawImage(
                overlay,
                -overlay.width / 2,
                -overlay.height / 2,
                overlay.width,
                overlay.height
            );
    
            ctx.restore();  // Reset transformations for the next overlay
        }
    
        // Return the final canvas for preview or sharing
        return finalCanvas;
    }

    function closePreview() {
        previewModal.style.display = 'none';
    }

    async function downloadImage() {
        const canvas = await renderFinalImage(2);
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 1.0));
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'meme.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async function shareToTelegram() {
        const canvas = await renderFinalImage(2);
        const imageData = canvas.toDataURL('image/png').split(',')[1];
        const url = `https://t.me/share/url?url=${encodeURIComponent(imageData)}`;
        window.open(url, '_blank');
    }

    async function shareToTwitter() {
        const canvas = await renderFinalImage(2);
        const imageData = canvas.toDataURL('image/png');
        const tweetText = 'Check out my meme!';
        const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`;
        window.open(url, '_blank');
    }

    async function shareNative() {
        const canvas = await renderFinalImage(2);
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 1.0));
        const file = new File([blob], 'meme.png', { type: 'image/png' });

        if (navigator.share) {
            await navigator.share({
                files: [file],
                title: 'Share Meme',
            });
        } else {
            downloadImage();
        }
    }

    window.onclick = function(event) {
        if (event.target === previewModal) {
            closePreview();
        }
    };

    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            closePreview();
        }
    });
</script>
</body>
</html>


